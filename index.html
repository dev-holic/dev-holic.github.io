<!DOCTYPE html><!--Z73PR_rCHDnk6IPuiINAb--><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="/_next/static/chunks/abdb394ac1358659.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/8b92303ff08c461e.js"/><script src="/_next/static/chunks/55aefddb5fcea8c7.js" async=""></script><script src="/_next/static/chunks/22253ee93289876a.js" async=""></script><script src="/_next/static/chunks/d87cd5742aeed2ef.js" async=""></script><script src="/_next/static/chunks/turbopack-2d45e4821fd8bdec.js" async=""></script><script src="/_next/static/chunks/28ff6a04602448ba.js" async=""></script><script src="/_next/static/chunks/64c697a3cb51cd07.js" async=""></script><script src="/_next/static/chunks/c6311bd1204a06f2.js" async=""></script><script src="/_next/static/chunks/5ec360913fe0c25f.js" async=""></script><script src="/_next/static/chunks/c8696c5ee1a86c19.js" async=""></script><link rel="icon" type="image/svg+xml" href="/vite.svg"/><meta name="google-site-verification" content="sXxEHSK4sTx3BrDha-kpJpFaszf3wxeSU5ojx8sqq1A"/><title>Dev-Holic Blog</title><meta name="description" content="Dev-Holic Blog - Tech, Development, and more"/><meta property="og:title" content="Dev-Holic Blog"/><meta property="og:description" content="Tech, Development, and more"/><meta property="og:url" content="https://dev-holic.github.io"/><meta property="og:site_name" content="Dev-Holic Blog"/><meta property="og:locale" content="ko_KR"/><meta property="og:image:alt" content="Dev-Holic Blog"/><meta property="og:image:type" content="image/png"/><meta property="og:image" content="https://dev-holic.github.io/opengraph-image?3ae57bf970b1b170"/><meta property="og:image:width" content="1200"/><meta property="og:image:height" content="630"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="Dev-Holic Blog"/><meta name="twitter:description" content="Tech, Development, and more"/><meta name="twitter:image:alt" content="Dev-Holic Blog"/><meta name="twitter:image:type" content="image/png"/><meta name="twitter:image" content="https://dev-holic.github.io/opengraph-image?3ae57bf970b1b170"/><meta name="twitter:image:width" content="1200"/><meta name="twitter:image:height" content="630"/><script src="/_next/static/chunks/a6dad97d9634a72d.js" noModule=""></script></head><body class="bg-white text-gray-900 dark:bg-gray-900 dark:text-gray-100"><div hidden=""><!--$--><!--/$--></div><script type="application/ld+json">{"@context":"https://schema.org","@type":"WebSite","name":"Dev-Holic Blog","url":"https://dev-holic.github.io"}</script><div class="relative mx-auto flex h-screen w-full max-w-7xl flex-col overflow-hidden md:flex-row"><main class="h-full w-full flex-1 overflow-y-auto"><!--$!--><template data-dgst="BAILOUT_TO_CLIENT_SIDE_RENDERING"></template><div>Loading posts...</div><!--/$--><!--$--><!--/$--></main><!--$!--><template data-dgst="BAILOUT_TO_CLIENT_SIDE_RENDERING"></template><!--/$--></div><script src="/_next/static/chunks/8b92303ff08c461e.js" id="_R_" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"1:\"$Sreact.fragment\"\n4:I[97990,[\"/_next/static/chunks/28ff6a04602448ba.js\",\"/_next/static/chunks/64c697a3cb51cd07.js\"],\"OutletBoundary\"]\n5:\"$Sreact.suspense\"\n7:I[97990,[\"/_next/static/chunks/28ff6a04602448ba.js\",\"/_next/static/chunks/64c697a3cb51cd07.js\"],\"ViewportBoundary\"]\n9:I[97990,[\"/_next/static/chunks/28ff6a04602448ba.js\",\"/_next/static/chunks/64c697a3cb51cd07.js\"],\"MetadataBoundary\"]\nb:I[60740,[],\"default\"]\n:HL[\"/_next/static/chunks/abdb394ac1358659.css\",\"style\"]\n0:{\"P\":null,\"b\":\"Z73PR_rCHDnk6IPuiINAb\",\"c\":[\"\",\"\"],\"q\":\"\",\"i\":false,\"f\":[[[\"\",{\"children\":[\"__PAGE__\",{}]},\"$undefined\",\"$undefined\",true],[[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/chunks/abdb394ac1358659.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}],[\"$\",\"script\",\"script-0\",{\"src\":\"/_next/static/chunks/c6311bd1204a06f2.js\",\"async\":true,\"nonce\":\"$undefined\"}],[\"$\",\"script\",\"script-1\",{\"src\":\"/_next/static/chunks/5ec360913fe0c25f.js\",\"async\":true,\"nonce\":\"$undefined\"}]],\"$L2\"]}],{\"children\":[[\"$\",\"$1\",\"c\",{\"children\":[\"$L3\",[[\"$\",\"script\",\"script-0\",{\"src\":\"/_next/static/chunks/c8696c5ee1a86c19.js\",\"async\":true,\"nonce\":\"$undefined\"}]],[\"$\",\"$L4\",null,{\"children\":[\"$\",\"$5\",null,{\"name\":\"Next.MetadataOutlet\",\"children\":\"$@6\"}]}]]}],{},null,false,false]},null,false,false],[\"$\",\"$1\",\"h\",{\"children\":[null,[\"$\",\"$L7\",null,{\"children\":\"$L8\"}],[\"$\",\"div\",null,{\"hidden\":true,\"children\":[\"$\",\"$L9\",null,{\"children\":[\"$\",\"$5\",null,{\"name\":\"Next.Metadata\",\"children\":\"$La\"}]}]}],null]}],false]],\"m\":\"$undefined\",\"G\":[\"$b\",[]],\"S\":true}\n"])</script><script>self.__next_f.push([1,"c:I[27531,[\"/_next/static/chunks/28ff6a04602448ba.js\",\"/_next/static/chunks/64c697a3cb51cd07.js\"],\"default\"]\nd:I[44600,[\"/_next/static/chunks/28ff6a04602448ba.js\",\"/_next/static/chunks/64c697a3cb51cd07.js\"],\"default\"]\ne:I[71695,[\"/_next/static/chunks/c6311bd1204a06f2.js\",\"/_next/static/chunks/5ec360913fe0c25f.js\"],\"Sidebar\"]\nf:I[91320,[\"/_next/static/chunks/c6311bd1204a06f2.js\",\"/_next/static/chunks/5ec360913fe0c25f.js\",\"/_next/static/chunks/c8696c5ee1a86c19.js\"],\"PostList\"]\n"])</script><script>self.__next_f.push([1,"2:[\"$\",\"html\",null,{\"lang\":\"en\",\"children\":[[\"$\",\"link\",null,{\"rel\":\"icon\",\"type\":\"image/svg+xml\",\"href\":\"/vite.svg\"}],[\"$\",\"meta\",null,{\"name\":\"google-site-verification\",\"content\":\"sXxEHSK4sTx3BrDha-kpJpFaszf3wxeSU5ojx8sqq1A\"}],[\"$\",\"body\",null,{\"className\":\"bg-white text-gray-900 dark:bg-gray-900 dark:text-gray-100\",\"children\":[[\"$\",\"script\",null,{\"type\":\"application/ld+json\",\"dangerouslySetInnerHTML\":{\"__html\":\"{\\\"@context\\\":\\\"https://schema.org\\\",\\\"@type\\\":\\\"WebSite\\\",\\\"name\\\":\\\"Dev-Holic Blog\\\",\\\"url\\\":\\\"https://dev-holic.github.io\\\"}\"}}],[\"$\",\"div\",null,{\"className\":\"relative mx-auto flex h-screen w-full max-w-7xl flex-col overflow-hidden md:flex-row\",\"children\":[[\"$\",\"main\",null,{\"className\":\"h-full w-full flex-1 overflow-y-auto\",\"children\":[\"$\",\"$Lc\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$Ld\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":404}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],[]],\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]}],[\"$\",\"$Le\",null,{\"tags\":[\"AI\",\"APM\",\"App Router\",\"Blog\",\"CLI\",\"Datadog\",\"FP\",\"Gemini\",\"Giscus\",\"GitHub Discussions\",\"JavaScript\",\"Monitoring\",\"NPM\",\"Next.js\",\"OOP\",\"RSS\",\"RUM\",\"React Query\",\"Sentry\",\"Singleton\",\"Structure\",\"Symbol.for\",\"Test\",\"Tip\",\"architecture\",\"content-visibility\",\"css\",\"frontend\",\"globalThis\",\"javascript\",\"performance\",\"virtualization\",\"개발\",\"개발 블로그\",\"댓글 시스템\",\"무료\",\"터미널\"]}]]}]]}]]}]\n"])</script><script>self.__next_f.push([1,"10:T14d5,"])</script><script>self.__next_f.push([1,"\n# 🚀 Gemini CLI 완벽 가이드\n\nGemini CLI는 터미널에서 Google의 Gemini 모델과 직접 상호작용하며 코딩, 문서 작업, 시스템 관리 등을 수행할 수 있는 강력한 도구입니다.\n\n## 1. 설정 (Configuration)\n\n### 설치\nNode.js 환경에서 npm을 통해 간단히 설치할 수 있습니다.\n\n```bash\nnpm install -g @google/gemini-cli\n\n# 또는 설치 없이 바로 실행하려면\nnpx @google/gemini-cli\n```\n\n### 인증 (Authentication)\n설치 후 처음 실행하면 인증 절차가 진행됩니다.\n\n```bash\ngemini\n```\n\n* **Google 로그인 (권장):** 개인 사용자라면 브라우저를 통해 Google 계정으로 로그인하는 것이 가장 간편합니다.\n* **API Key:** `GEMINI_API_KEY` 환경 변수를 설정하여 AI Studio에서 발급받은 키를 사용할 수 있습니다.\n* **Vertex AI:** 기업/클라우드 사용자의 경우 `gcloud` 인증이나 서비스 계정을 통해 Vertex AI 모델을 사용할 수 있습니다.\n\n### 설정 파일\nGemini CLI의 동작은 `settings.json` 파일을 통해 제어됩니다.\n\n* **전역 설정:** `~/.gemini/settings.json`\n* **프로젝트별 설정:** 프로젝트 루트의 `.gemini/settings.json` (이 설정이 전역 설정보다 우선함)\n* **.env 파일 지원:** `.gemini/.env` 파일을 만들어 API 키나 프로젝트 ID 같은 환경 변수를 관리할 수 있습니다.\n\n---\n\n## 2. 기본 사용법 (Basic Usage)\n\nGemini CLI는 크게 **Slash 명령어(/)**, **At 명령어(@)**, **Shell 명령어(!)** 세 가지 방식으로 조작합니다.\n\n### 🔹 Slash 명령어 (기능 제어)\nCLI의 기능을 제어하거나 설정을 변경할 때 사용합니다.\n\n* `/help`: 도움말 및 명령어 목록 확인\n* `/clear` (또는 `Ctrl+L`): 화면 초기화\n* `/chat save \u003c태그\u003e`: 현재 대화 상태 저장\n* `/chat resume \u003c태그\u003e`: 저장된 대화 불러오기\n* `/model`: 사용할 Gemini 모델 변경 (예: Gemini 1.5 Pro, Flash 등)\n* `/settings`: 설정 메뉴 열기\n\n### 🔹 At 명령어 (컨텍스트 주입)\n파일이나 폴더의 내용을 프롬프트에 포함시킬 때 사용합니다.\n\n* `@filename.js`: 특정 파일의 내용을 읽어 프롬프트에 추가\n* `@src/`: 해당 디렉토리(및 하위 디렉토리)의 모든 텍스트 파일 내용을 추가\n* `@README.md 이 파일을 요약해줘`: 파일 내용을 바탕으로 질문\n\n### 🔹 Shell 명령어 (시스템 실행)\n터미널 명령어를 직접 실행하거나 Gemini에게 실행을 맡길 수 있습니다.\n\n* `!ls -la`: 현재 폴더 파일 목록 출력 (직접 실행)\n* `!`: Shell 모드로 전환 (프롬프트가 쉘 명령어로 인식됨)\n\n---\n\n## 3. 잘 활용할 수 있는 팁 (Tips)\n\n### 🛠 커스텀 커맨드 (Custom Commands) 만들기\n자주 쓰는 복잡한 프롬프트를 단축키처럼 만들 수 있습니다. `.gemini/commands/` 폴더에 `.toml` 파일을 생성하여 정의합니다.\n\n**예시: `/refactor` 명령어로 코드를 정리하도록 설정**\n파일 경로: `~/.gemini/commands/refactor.toml`\n\n```toml\ndescription = \"코드를 리팩토링하고 설명을 추가합니다.\"\nprompt = \"\"\"\n다음 코드를 클린 코드 원칙에 따라 리팩토링해줘.\n변경 사항에 대한 주석도 달아줘: {{args}}\n\"\"\"\n```\n* **사용법:** `/refactor @main.js`\n\n### ⌨️ 단축키 활용\n* `Ctrl + L`: 화면 클리어\n* `Ctrl + Z`: 입력 실행 취소 (Undo)\n* `Ctrl + C`: 현재 작업 취소\n* `Tab`: 자동 완성 수락\n\n### 📂 프로젝트별 컨텍스트 관리 (GEMINI.md)\n프로젝트 루트나 폴더에 `GEMINI.md` 파일을 만들고 프로젝트에 대한 설명, 코딩 컨벤션, 규칙 등을 적어두면 Gemini가 이를 \"기억(Memory)\"으로 인식하여 항상 해당 규칙을 따르며 답변합니다.\n\n* **팁:** 컨벤션이 변경되었다면 `/memory refresh` 명령어로 `GEMINI.md` 내용을 갱신하세요.\n\n### 🔧 내장 도구 (Tools) 활용\nGemini는 단순 텍스트 생성 외에도 실제 작업을 수행할 수 있는 도구들을 가지고 있습니다.\n\n* `run_shell_command`: 쉘 명령어 실행 (예: \"git status 확인해줘\")\n* `read_file` / `write_file`: 파일 읽기 및 생성/수정\n* `web_fetch`: 특정 URL의 웹페이지 내용 긁어오기\n\n---\n\n## 4. 활용 예시 (Examples)\n\n### 📸 이미지 파일 일괄 이름 변경\n파일 내용을 인식하여 이름을 바꿔달라고 요청할 수 있습니다.\n\u003e **User:** \"photos 폴더에 있는 이미지들의 내용을 보고 적절한 이름으로 변경해줘.\"\n\u003e\n\u003e **Gemini:** (각 이미지를 분석 후) `run_shell_command`를 사용하여 `mv photo1.jpg sunset_beach.jpg` 등의 명령을 제안하고 실행 승인을 요청함.\n\n### 💻 오픈소스 코드 분석\n방대한 코드를 빠르게 파악할 때 유용합니다.\n\u003e **User:** \"`@src/` 폴더의 코드 구조를 파악하고, `app.js`가 어떻게 동작하는지 다이어그램을 그리듯이 설명해줘.\"\n\n### 📊 데이터 병합 및 가공\n\u003e **User:** \"`data_2023.csv`와 `data_2024.csv` 파일을 합치고, 매출 컬럼을 기준으로 내림차순 정렬해서 `total_sales.csv`로 저장해줘.\"\n\n### 🧪 테스트 코드 자동 생성\n\u003e **User:** \"`@login.ts` 파일을 읽고 이에 대한 Jest 유닛 테스트 코드를 작성해서 `login.test.ts` 파일로 만들어줘.\"\n"])</script><script>self.__next_f.push([1,"11:T1aeb,"])</script><script>self.__next_f.push([1,"\n# [가이드] Giscus: 광고 없는 무료 댓글 시스템, 5분 만에 적용하기\n\n개발 블로그를 운영하다 보면 독자와의 소통을 위해 댓글 기능이 필요합니다. Disqus는 무겁고 광고가 많고, Utterances는 GitHub Issues를 사용해서 댓글이 이슈로 등록되는 부담이 있습니다.\n\n이때 가장 좋은 대안이 바로 **Giscus**입니다. GitHub Discussions API를 활용하기 때문에 관리가 편하고, 디자인이 깔끔하며, 마크다운을 지원합니다.\n\n## 1. 사전 준비 (GitHub 설정)\n\nGiscus를 사용하려면 먼저 GitHub 저장소(Repository)가 준비되어 있어야 합니다.\n\n1.  **Public Repository 생성**: 댓글을 저장할 저장소는 반드시 **Public**이어야 합니다. (블로그 소스 코드 저장소를 그대로 써도 되고, 댓글용 저장소를 따로 파도 됩니다.)\n2.  **Giscus 앱 설치**: [GitHub Apps - Giscus](https://github.com/apps/giscus) 링크로 이동하여 `Install`을 클릭합니다. 위에서 준비한 저장소에 접근 권한을 허용해주세요.\n3.  **Discussions 활성화**:\n    * 해당 저장소의 **Settings** \u003e **General** 탭으로 이동합니다.\n    * `Features` 섹션에서 **Discussions** 체크박스를 켜서 활성화합니다.\n\n## 2. 스크립트 생성 (설정값 추출)\n\n[Giscus 공식 홈페이지](https://giscus.app/ko)로 이동하여 저장소 정보를 입력하면 자동으로 설정 코드를 만들어줍니다.\n\n1.  **저장소(Repository) 입력**: `username/repo-name` 형식으로 입력합니다. (예: `my-id/my-blog-comments`)\n    * *입력 후 로딩이 끝나면 아래 '페이지와 discussion 연결' 단계로 넘어갑니다.*\n2.  **연결 방식 선택 (Page ↔ Discussion Mapping)**:\n    * `pathname`: URL 경로를 기준으로 매칭 (추천, URL이 바뀌면 댓글도 새로 시작됨)\n    * `og:title`: `\u003cmeta property=\"og:title\"\u003e` 태그 내용 기준\n    * 보통 블로그라면 `pathname`이 가장 무난합니다.\n3.  **Discussion 카테고리 선택**:\n    * 보통 `General`이나 `Announcements`를 선택합니다.\n    * **주의**: 선택한 카테고리는 GitHub Discussions 탭에서 **누구나 글을 쓸 수 있는 권한**이 있어야 합니다. (\"Announcements\"는 관리자만 쓸 수 있는 경우가 많으니 권한 설정을 확인하거나 `General`을 추천합니다.)\n4.  **기능 및 테마 선택**:\n    * **메타데이터 전송**: 댓글 위에 페이지 정보를 표시할지 선택.\n    * **테마**: 사이트 분위기에 맞춰 선택 (Light/Dark/Preferred Color Scheme 등).\n\n## 3. 코드 적용하기\n\n위 설정을 마치면 하단에 `\u003cscript\u003e` 태그가 생성됩니다. 개발 환경에 맞춰 적용하세요.\n\n### 방법 A: 일반 HTML / 정적 사이트 (Jekyll, Hugo 등)\n\n생성된 스크립트 태그를 댓글이 표시될 위치(보통 포스트 하단)에 붙여넣기만 하면 됩니다.\n\n```html\n\u003cscript src=\"[https://giscus.app/client.js](https://giscus.app/client.js)\"\n        data-repo=\"[ENTER REPO HERE]\"\n        data-repo-id=\"[ENTER REPO ID HERE]\"\n        data-category=\"[ENTER CATEGORY NAME HERE]\"\n        data-category-id=\"[ENTER CATEGORY ID HERE]\"\n        data-mapping=\"pathname\"\n        data-strict=\"0\"\n        data-reactions-enabled=\"1\"\n        data-emit-metadata=\"0\"\n        data-input-position=\"bottom\"\n        data-theme=\"preferred_color_scheme\"\n        data-lang=\"ko\"\n        crossorigin=\"anonymous\"\n        async\u003e\n\u003c/script\u003e\n```\n\n### 방법 B: React / Next.js (컴포넌트화)\n\nReact 환경에서는 `script` 태그를 직접 넣기보다 `useEffect`를 활용하거나 전용 컴포넌트를 만드는 것이 좋습니다. Next.js 등에서 라우팅 이동 시 댓글이 제대로 다시 로드되게 하려면 아래와 같이 작성합니다.\n\n```tsx\n// components/Giscus.tsx\nimport { useEffect, useRef } from 'react';\n\nexport default function Giscus() {\n  const ref = useRef\u003cHTMLDivElement\u003e(null);\n\n  // 테마가 바뀔 때 giscus 테마도 업데이트하려면 이 로직이 추가로 필요합니다.\n  // const theme = useTheme(); // (프로젝트의 테마 hook 사용)\n\n  useEffect(() =\u003e {\n    if (!ref.current || ref.current.hasChildNodes()) return;\n\n    const scriptElem = document.createElement('script');\n    scriptElem.src = '[https://giscus.app/client.js](https://giscus.app/client.js)';\n    scriptElem.async = true;\n    scriptElem.crossOrigin = 'anonymous';\n\n    // 설정값 주입 (giscus 웹사이트에서 생성된 값 복사)\n    scriptElem.setAttribute('data-repo', '사용자명/저장소명');\n    scriptElem.setAttribute('data-repo-id', 'R_kgDO...'); // ⚠️ 직접 생성된 값 확인 필수\n    scriptElem.setAttribute('data-category', 'General');\n    scriptElem.setAttribute('data-category-id', 'DIC_kwDO...'); // ⚠️ 직접 생성된 값 확인 필수\n    scriptElem.setAttribute('data-mapping', 'pathname');\n    scriptElem.setAttribute('data-strict', '0');\n    scriptElem.setAttribute('data-reactions-enabled', '1');\n    scriptElem.setAttribute('data-emit-metadata', '0');\n    scriptElem.setAttribute('data-input-position', 'bottom');\n    scriptElem.setAttribute('data-theme', 'preferred_color_scheme');\n    scriptElem.setAttribute('data-lang', 'ko');\n\n    ref.current.appendChild(scriptElem);\n  }, []);\n\n  // 테마 변경 동적 반영을 위한 postMessage (선택사항)\n  // useEffect(() =\u003e {\n  //   const iframe = document.querySelector\u003cHTMLIFrameElement\u003e('iframe.giscus-frame');\n  //   iframe?.contentWindow?.postMessage({ giscus: { setConfig: { theme } } }, '[https://giscus.app](https://giscus.app)');\n  // }, [theme]);\n\n  return \u003csection ref={ref} /\u003e;\n}\n```\n\n## 4. 트러블 슈팅 \u0026 꿀팁\n\n1.  **403 Forbidden / Not Found 오류**:\n    * `data-repo-id`와 `data-category-id`가 정확한지 확인하세요. (단순히 텍스트 이름이 아니라 GitHub API에서 할당된 고유 ID 값이어야 합니다. 공식 사이트 생성기에서 복사하는 것이 가장 확실합니다.)\n    * Giscus 앱이 해당 저장소에 설치(Install)되어 있는지 확인하세요.\n2.  **댓글이 안 보일 때**:\n    * `giscus.json` 파일이 필요하지 않습니다. 저장소의 Discussions 탭에 실제로 'Giscus'라는 봇이 만든 discussion이 생성되는지 확인해보세요.\n3.  **다크모드 대응**:\n    * `data-theme=\"preferred_color_scheme\"`을 사용하면 OS 설정에 따라 자동으로 변합니다.\n    * 블로그 자체에 다크모드 토글이 있다면, 토글 이벤트 발생 시 `postMessage`를 보내 테마를 즉시 변경해 주는 것이 사용자 경험(UX)에 좋습니다.\n\n---\n\n**마무리하며**\n\nGiscus는 GitHub 아이디만 있다면 누구나 쉽게 댓글을 남길 수 있고, 개발자 입장에서는 DB 관리 부담 없이 무료로 사용할 수 있는 최고의 솔루션입니다. 지금 바로 적용해 보세요!\n"])</script><script>self.__next_f.push([1,"12:T139e,"])</script><script>self.__next_f.push([1,"\n# [Tip] RSS란 무엇인가? 내 기술 블로그에 RSS 달고 Feedly로 구독하기\n\n기술 블로그를 운영하다 보면 \"RSS 주소가 어떻게 되나요?\"라는 질문을 받거나, 다른 개발자의 블로그를 효율적으로 구독하고 싶다는 생각이 들 때가 있습니다.\n\n오늘은 정보의 홍수 속에서 나만의 뉴스 피드를 구축하게 해주는 **RSS의 개념**과, **GitHub Pages(Jekyll) 블로그에 RSS를 적용하는 방법**, 그리고 대표적인 리더기인 **Feedly 사용법**까지 A to Z로 정리해 드립니다.\n\n---\n\n## 1. RSS Feed란 무엇인가?\n\n**RSS(Really Simple Syndication)**는 웹사이트의 콘텐츠 업데이트 정보를 사용자에게 자동으로 배달해주는 규약입니다. 쉽게 말해, 매일 아침 문 앞으로 배달되는 '신문'과 같습니다.\n\n### 왜 필요한가요?\n우리가 즐겨찾는 기술 블로그나 뉴스 사이트가 20군데 있다고 가정해 봅시다.\n* **RSS가 없다면:** 매일 20군데 사이트를 일일이 들어가 \"새 글이 올라왔나?\" 확인해야 합니다. (비효율적)\n* **RSS가 있다면:** 'RSS 리더'라는 앱 한 곳만 보면 됩니다. 새 글이 올라온 사이트의 콘텐츠만 쏙 뽑아서 모아 보여줍니다. (효율적)\n\n### 핵심 장점\n1.  **시간 절약:** 여러 사이트를 순회하는 시간을 줄여줍니다.\n2.  **알고리즘 해방:** 유튜브나 SNS처럼 AI가 추천하는 글이 아니라, 내가 구독한 양질의 글을 시간 순서대로 빠짐없이 볼 수 있습니다.\n3.  **광고 없는 읽기:** 웹사이트의 복잡한 레이아웃이나 광고 없이 본문 텍스트에만 집중할 수 있습니다.\n\n---\n\n## 2. 내 블로그에 RSS 적용하기 (GitHub Pages + Jekyll 예시)\n\nGitHub Pages의 기본 엔진인 **Jekyll**을 사용하고 있다면, 플러그인 하나로 아주 쉽게 RSS Feed(`feed.xml`)를 생성할 수 있습니다.\n\n### Step 1: `_config.yml` 설정\n블로그 루트 디렉토리에 있는 `_config.yml` 파일을 열어 `plugins` 항목에 `jekyll-feed`를 추가합니다.\n\n```yaml\n# _config.yml\n\nplugins:\n  - jekyll-feed\n```\n\n### Step 2: `Gemfile` 확인\n`Gemfile`에 `jekyll-feed` 플러그인이 포함되어 있는지 확인합니다. (GitHub Pages gem을 통째로 쓰고 있다면 생략해도 되지만, 명시해 주는 것이 좋습니다.)\n\n```ruby\n# Gemfile\n\ngroup :jekyll_plugins do\n  gem \"jekyll-feed\"\nend\n```\n수정 후 터미널에서 `bundle install`을 실행하여 의존성을 설치합니다.\n\n### Step 3: 로컬 테스트 및 배포\n로컬 서버를 실행하여 정상적으로 xml 파일이 생성되는지 확인합니다.\n\n```bash\nbundle exec jekyll serve\n```\n브라우저 주소창에 `http://localhost:4000/feed.xml`을 입력했을 때, XML 코드가 가득한 페이지가 뜬다면 성공입니다. 이제 변경 사항을 GitHub에 `push` 하면 배포가 완료됩니다.\n\n\u003e **Tip:** 방문자가 RSS 주소를 쉽게 찾을 수 있도록 블로그의 사이드바나 푸터(Footer)에 RSS 아이콘을 추가하고 링크(`https://내블로그주소.com/feed.xml`)를 걸어주세요.\n\n---\n\n## 3. Feedly로 RSS 구독하고 관리하기\n\n이제 내 블로그에도 RSS가 생겼고, 다른 좋은 기술 블로그들도 RSS를 지원합니다. 이를 한곳에서 모아보기 위해 가장 대중적인 리더기인 **Feedly(피들리)** 사용법을 알아봅시다.\n\n### Step 1: 가입 및 로그인\n[Feedly 공식 홈페이지](https://feedly.com)에 접속하여 구글, 애플, 트위터 등의 계정으로 가입합니다. (무료 플랜으로도 충분합니다.)\n\n### Step 2: 구독 추가하기 (Follow)\n1.  왼쪽 사이드바 메뉴에서 **'Follow Websites'** 또는 **'+'** 버튼을 클릭합니다.\n2.  검색창에 **구독하고 싶은 블로그의 URL**이나 **RSS 주소**를 입력합니다.\n    * *예: [https://techblog.woowahan.com](https://techblog.woowahan.com) (우아한형제들 기술블로그)*\n3.  검색 결과에 해당 블로그가 뜨면 **'FOLLOW'** 버튼을 누릅니다.\n\n### Step 3: 피드 분류하기 (Create Feed)\nFOLLOW를 누르면 이 블로그를 어떤 폴더에 넣을지 묻습니다. 주제별로 폴더(Feed)를 만들어 관리하면 편리합니다.\n* **Dev - Frontend** (프론트엔드 관련)\n* **Dev - Corporate** (기업 기술 블로그)\n* **Insight** (개발 외 인사이트)\n\n### Step 4: 읽기\n이제 매일 아침 Feedly 앱이나 웹사이트에 접속하기만 하면, 내가 구독한 모든 블로그의 최신 글들이 잡지처럼 정리되어 있습니다. 읽고 싶은 글을 클릭하여 편하게 읽으세요.\n\n---\n\n## 마치며\n\n개발자에게 **최신 기술 트렌드 파악**과 **양질의 정보 습득**은 코딩 실력만큼이나 중요합니다. 오늘 당장 내 블로그에 RSS를 달아 독자들에게 편의를 제공하고, 나 또한 Feedly를 통해 나만의 지식 큐레이션 시스템을 만들어보는 건 어떨까요?\n\n*Happy Coding \u0026 Happy Reading!*"])</script><script>self.__next_f.push([1,"13:T169c,"])</script><script>self.__next_f.push([1,"\n개발팀이 성장하고 서비스 규모가 커지면 필연적으로 **'모니터링(Monitoring)'**에 대한 니즈가 발생합니다. 시장에는 수많은 툴이 있지만, 가장 대표적인 두 가지를 꼽자면 단연 **Datadog(데이터독)**과 **Sentry(센트리)**일 것입니다.\n\n흔히 \"둘 다 모니터링 툴 아니야?\"라고 생각하기 쉽지만, 두 서비스는 **태생과 지향점**이 완전히 다릅니다. 이번 포스팅에서는 클라이언트, 서버 로깅, APM, RUM, 대시보드 구성 등을 기준으로 두 툴을 상세 비교하고, 어떤 상황에서 무엇을 선택해야 할지 정리해 보았습니다.\n\n## 1. 핵심 철학의 차이: 관제실 vs 현미경\n\n두 툴의 가장 큰 차이는 **'누구를 위해 만들어졌는가'**입니다.\n\n* **Datadog:** 인프라 엔지니어와 DevOps를 위한 **통합 관제실**. 숲을 보고 시스템 전체의 이상 징후를 감지하는 데 특화되어 있습니다.\n* **Sentry:** 애플리케이션 개발자를 위한 **디버깅 툴**. 나무를 보고 코드의 몇 번째 줄에서 에러가 났는지 분석하는 데 특화되어 있습니다.\n\n---\n\n## 2. 기능별 상세 비교\n\n### ① 로깅 및 에러 트래킹 (Client \u0026 Server)\n\n이 영역은 두 툴의 정체성이 가장 극명하게 갈리는 부분입니다.\n\n| 구분 | Sentry (개발자 중심) | Datadog (운영자 중심) |\n| :--- | :--- | :--- |\n| **Client (FE/App)** | **압도적 우위.** Source Map을 통해 난독화된 코드의 정확한 위치를 집어줍니다. Breadcrumbs로 유저의 이동 경로 추적이 가능합니다. | 로그 수집은 가능하나, 프론트엔드 디버깅을 위한 직관적인 정보(Stack trace 시각화 등)는 부족합니다. |\n| **Server Logging** | **Exception 중심.** 에러가 발생한 시점의 콜 스택 분석에 강력합니다. 단순 Info 로그를 쌓기엔 적합하지 않습니다. | **Log Management 강자.** 수십 기가의 로그를 쌓아두고 검색(Grep), 필터링, 시각화하는 능력이 탁월합니다. |\n| **Grouping** | 같은 에러를 지능적으로 하나로 묶어주는 기능이 매우 뛰어납니다. | 패턴으로 묶을 수 있으나 Sentry만큼 정교한 이슈 관리는 어렵습니다. |\n\n\u003e **Key Point:** 프론트엔드/백엔드 **코드의 버그를 잡으려면 Sentry**가 필수적이고, 서버의 **전반적인 로그(접속 로그, 시스템 로그 등)를 관리하려면 Datadog**이 필요합니다.\n\n### ② APM (Application Performance Monitoring)\n\n* **Sentry:** **트랜잭션 중심**입니다. \"이 API 호출이 왜 느리지?\"를 코드 레벨에서 파고듭니다. 특정 함수나 DB 쿼리의 병목을 찾는 데 유용하며 설정이 비교적 간편합니다.\n* **Datadog:** **인프라 + 트랜잭션**입니다. 코드 병목뿐만 아니라 CPU, 메모리, 네트워크, 디스크 I/O 등 인프라 지표와 연관 지어 분석합니다. 특히 MSA 환경에서 수십 개의 서비스가 얽혀있을 때의 **Service Map** 시각화 능력은 업계 표준 수준입니다.\n\n### ③ RUM (Real User Monitoring) \u0026 Session Replay\n\n* **Sentry:** **디버깅을 위한 UX 분석**에 가깝습니다. Core Web Vitals(LCP, FID) 측정에 충실하며, **Session Replay** 기능을 통해 유저가 에러를 겪은 순간의 화면을 녹화해서 보여줍니다. 이는 버그 재현에 엄청난 도움을 줍니다.\n* **Datadog:** **비즈니스 인사이트 도출**까지 가능합니다. 사용자의 지역, 기기, 네트워크 상태 등 방대한 데이터를 수집합니다. Session Replay도 제공하지만, UX 분석 툴(Hotjar 등) 수준의 디테일과 마케팅적 데이터를 제공하는 대신 비용이 비쌉니다.\n\n### ④ 대시보드 구성 (Customizability)\n\n* **Sentry:** **낮은 자유도.** \"할 일 목록(To-Do List)\"에 가깝습니다. 이슈 목록, 릴리즈 현황 등 Sentry가 제공하는 뷰를 따라야 합니다. 개발자가 에러를 처리하는 워크플로우에 최적화되어 있습니다.\n* **Datadog:** **높은 자유도.** NASA 관제실 같은 대시보드를 만들 수 있습니다. 로그 수, CPU 사용량, 심지어 매출액까지 원하는 모든 지표를 위젯으로 만들어 한 화면에 구성할 수 있습니다.\n\n---\n\n## 3. 가격 (Cost)\n\n현실적으로 가장 중요한 부분입니다.\n\n* **Sentry:** 상대적으로 합리적이고 예측 가능합니다. (사용자 수 + 이벤트 수 기반)\n* **Datadog:** **비쌉니다.** 호스트 당, 로그 용량 당, APM 호스트 당, RUM 세션 당 과금이 따로 붙습니다. 자칫하면 요금 폭탄을 맞을 수 있어 핀옵스(FinOps) 관점의 관리가 필요합니다.\n\n---\n\n## 4. 결론: 무엇을 선택해야 할까?\n\n### Sentry를 먼저 도입하세요, 만약...\n* 서비스 초기~중기 단계이다.\n* **프론트엔드(Web/App)** 의 비중이 크고 사용자 경험이 중요하다.\n* \"서버가 죽는 것\"보다 \"기능이 동작 안 하는 버그\"가 더 큰 문제다.\n* 개발자가 직접 모니터링하고 코드를 수정한다.\n\n### Datadog이 필요합니다, 만약...\n* 트래픽이 많고 **MSA(Microservices)** 구조로 인프라가 복잡하다.\n* DevOps/SRE 팀이 별도로 존재한다.\n* 비용보다 **안정성과 통합 관제**가 최우선이다.\n* 규정상 로그를 장기간 보존하고 검색해야 한다.\n\n### 💡 Best Practice\n사실 예산이 허락한다면 **두 가지를 같이 쓰는 것이 가장 이상적**입니다.\n\n* **Frontend \u0026 App:** Sentry (에러 잡기, 화면 녹화)\n* **Backend \u0026 Infra:** Datadog (서버 상태, APM, 대량 로그)\n\n각 툴의 강점이 명확한 만큼, 팀의 상황과 목적에 맞춰 적절한 도구를 선택하시길 바랍니다.\n"])</script><script>self.__next_f.push([1,"14:T29be,"])</script><script>self.__next_f.push([1,"\n1. 서론: 끝나지 않는 로딩의 미스터리\n\nNext.js App Router는 서버 컴포넌트와 클라이언트 컴포넌트의 유연한 조합을 통해 강력한 웹 애플리케이션 구축을 가능하게 합니다. 하지만 이 새로운 렌더링 패러다임은 강력한 만큼, 기존의 클라이언트 중심 멘탈 모델과 충돌하며 흔한 함정을 만들어냅니다. 그 대표적인 사례가 바로 @tanstack/react-query의 useSuspenseQuery를 클라이언트 컴포넌트에서 사용했을 때 발생하는 '서버 행(Hanging)' 현상, 즉 페이지 응답이 멈추고 무한 로딩에 빠지는 문제입니다.\n\n이 글은 이 문제를 단순한 버그가 아닌, 서버 우선 렌더링 모델과 클라이언트 데이터 페칭 패턴이 충돌할 때 발생하는 예측 가능한 결과로 분석합니다. 우리는 이 현상의 근본 원인을 명확히 파헤치고, next/dynamic을 활용해 의도적인 렌더링 경계를 설정하는 확실한 해결책을 제시할 것입니다. 이제 문제 상황을 구체적으로 재현하며 본격적인 분석을 시작하겠습니다.\n\n2. 문제 현상 분석: useSuspenseQuery가 서버를 멈추게 할 때\n\n모든 문제 해결의 첫걸음은 현상을 명확하게 정의하고 재현하는 것입니다. 정확한 진단 없이는 올바른 처방을 내릴 수 없기 때문입니다. 어떤 환경과 코드 구조에서 이 문제가 발생하는지 구체적으로 살펴보겠습니다.\n\n문제는 다음과 같은 시나리오에서 발생합니다.\n\n* 환경: Next.js App Router\n* 구조: 서버 컴포넌트(Server Component)가 `\u003cSuspense\u003e` fallback UI로 클라이언트 컴포넌트(Client Component)를 감싸는 구조\n* 핵심 원인: 감싸진 클라이언트 컴포넌트 내부에서 @tanstack/react-query의 useSuspenseQuery를 호출함\n\n이 조건들이 충족될 때 나타나는 가장 명백한 증상은 다음과 같습니다. 페이지 응답이 완료되지 않고 브라우저 탭의 파비콘이 계속 로딩 상태로 남아있는 '서버 행(Hanging)' 현상이 발생합니다. 사용자는 아무런 콘텐츠도 보지 못한 채 끝없이 기다리게 되고, 개발자 도구의 네트워크 탭을 봐도 응답이 오지 않는 것을 확인할 수 있습니다.\n\n이처럼 서버가 응답을 멈추는 현상은 왜 발생하는 것일까요? 이 근본적인 원인을 파헤치기 위해서는, 우리가 흔히 오해하는 클라이언트 컴포넌트의 렌더링 방식에 대한 정확한 이해가 필요합니다.\n\n3. 근본 원인 탐구: 'use client'의 오해와 진실\n\n단순히 현상을 해결하는 것을 넘어, Next.js App Router의 핵심 렌더링 메커니즘을 이해하는 것은 매우 중요합니다. 이번 문제의 근원은 바로 'use client' 지시어에 대한 흔한 오해에서 비롯됩니다.\n\n'use client'는 CSR을 의미하지 않는다\n\n많은 개발자가 'use client' 지시어를 파일 상단에 추가하면 해당 컴포넌트가 오직 브라우저에서만 렌더링(Client-Side Rendering, CSR)될 것이라고 생각합니다. 하지만 이는 사실이 아닙니다. 이 동작은 Next.js에 국한된 것이 아니라, React 18의 Suspense 기반 SSR의 고유한 특성입니다. 'use client'의 정확한 의미는 다음과 같습니다.\n\n* Pre-rendering (사전 렌더링): 'use client'로 명시된 컴포넌트조차도, 최초 페이지 로드 시에는 서버에서 초기 HTML 뼈대를 미리 렌더링(Server-Side Rendering, SSR)합니다.\n* Hydration (하이드레이션): 이후 브라우저에서 JavaScript 번들이 로드되면, 서버가 생성한 HTML 위에 이벤트 핸들러 등을 연결하여 상호작용이 가능한 완전한 컴포넌트로 '깨우는' 과정을 거칠니다.\n\n즉, 별도의 설정이 없는 한 모든 클라이언트 컴포넌트는 서버에서 최소 한 번 실행됩니다. 바로 이 지점이 useSuspenseQuery가 서버 행을 유발하는 원인입니다. 그 메커니즘은 다음과 같습니다.\n\n1. 서버 렌더링 시도: 사용자가 페이지에 접속하면, Next.js 서버는 UI를 구성하는 클라이언트 컴포넌트의 최초 HTML 렌더링을 시도합니다.\n2. 데이터 부재와 Suspend: 서버 환경에는 react-query가 관리하는 클라이언트 측 캐시 데이터가 존재하지 않습니다. 따라서 useSuspenseQuery는 데이터를 가져오기 위해 Promise를 던지고(throw), 컴포넌트를 'Suspend(일시 중단)' 상태로 만듭니다.\n3. 무한 대기: 서버에 있는 부모 `\u003cSuspense\u003e` 경계가 이 Promise를 감지합니다. 이는 Next.js 서버의 렌더러에게 \"이 부분의 HTML 생성을 중단하고 Promise가 해결될 때까지 기다려라\"는 신호입니다. 하지만 이 Promise는 클라이언트 사이드 데이터 페칭 로직이므로 서버에서는 절대 해결될 수 없습니다. 결과적으로, Next.js 서버의 응답 스트림 전송이 중단된 채 무기한 대기하게 되는 '행(Hanging)' 상태에 빠집니다.\n\n결국 문제의 원인은 클라이언트에서만 실행되어야 할 데이터 페칭 로직이 서버 렌더링 과정 중 시도되었기 때문입니다. 이를 해결하기 위한 전략은 명확합니다. 해당 컴포넌트의 서버 렌더링 자체를 의도적으로 비활성화하는 것입니다.\n\n4. 해결책 제시: next/dynamic과 ssr: false 옵션\n\n문제의 원인이 서버 렌더링 시도에 있다는 것을 파악했으니, 이제 명확한 해결책을 제시할 차례입니다. 우리는 해당 컴포넌트를 기본 SSR/Hydration 모델에서 의도적으로 제외하고, 순수한 클라이언트 사이드 렌더링(CSR) 경계를 설정해야 합니다.\n\n이때 사용할 수 있는 가장 강력한 도구가 바로 Next.js의 내장 기능인 next/dynamic입니다. next/dynamic은 컴포넌트를 동적으로 임포트하게 해주며, 특히 ssr: false 옵션과 함께 사용될 때 이 문제의 완벽한 해결책이 됩니다.\n\nssr: false 옵션의 역할은 매우 직관적입니다. 이것은 Next.js 서버에게 **\"이 컴포넌트의 HTML은 미리 만들지 말고, 브라우저에서 JavaScript가 로드된 후에 렌더링을 시작하라\"**고 명확히 지시하는 것과 같습니다.\n\n이 해결책을 적용했을 때 얻게 되는 결과는 다음과 같습니다.\n\n* 서버는 해당 컴포넌트의 렌더링을 완전히 건너뛰고 나머지 페이지의 HTML을 구성하여 즉시 클라이언트에 응답을 보냅니다.\n* 클라이언트(브라우저)는 초기 HTML을 받은 후, 해당 컴포넌트의 JavaScript 코드를 비동기적으로 로드합니다.\n* 로드가 완료되면, 실제 데이터 페칭(useSuspenseQuery)과 렌더링은 온전히 클라이언트 환경에서만 일어나므로 서버 행 이슈가 근본적으로 해결됩니다.\n\n이론적 설명을 마쳤으니, 이제 실제 코드를 통해 이 해결책을 어떻게 적용하는지 구체적으로 살펴보겠습니다.\n\n5. 적용 코드 예시: 문제 해결의 실제\n\n앞서 설명한 해결책을 실제 코드에 어떻게 적용하는지 보여드리겠습니다. 부모인 서버 컴포넌트에서 useSuspenseQuery를 사용하는 자식 클라이언트 컴포넌트를 불러오는 방식을 어떻게 변경하는지 집중해서 보시기 바랍니다.\n\n먼저 부모 컴포넌트인 **ServerComponent.tsx**의 변경 사항입니다. import 구문을 next/dynamic으로 대체하고 ssr: false 옵션을 추가합니다.\n\n```typescript\n// ServerComponent.tsx (부모 컴포넌트)\nimport dynamic from 'next/dynamic';\n\n// 핵심: ssr: false 옵션으로 서버 렌더링을 비활성화\nconst ClientComponentWithNoSSR = dynamic(\n  () =\u003e import('./ClientComponent'),\n  {\n    ssr: false,\n    // 컴포넌트의 JS가 로드되는 동안 보여줄 UI\n    loading: () =\u003e \u003cp\u003eLoading...\u003c/p\u003e,\n  }\n);\n\nexport default function Page() {\n  return (\n    \u003cdiv\u003e\n      \u003ch1\u003eMy Page\u003c/h1\u003e\n      {/* 서버 행 이슈 없이 클라이언트에서만 렌더링됩니다. */}\n      \u003cClientComponentWithNoSSR /\u003e\n    \u003c/div\u003e\n  );\n}\n```\n\n\n다음은 **ClientComponent.tsx**의 코드입니다. 흥미롭게도 이 컴포넌트의 코드는 전혀 변경할 필요가 없습니다. next/dynamic을 통해 렌더링 제어의 책임이 부모 컴포넌트로 넘어갔기 때문입니다.\n\n```typescript\n// ClientComponent.tsx (자식 컴포넌트)\n'use client';\n\nimport { useSuspenseQuery } from '@tanstack/react-query';\n\n// 임의의 데이터 fetch 함수\nasync function fetchData() {\n  // 실제 네트워크 딜레이를 시뮬레이션\n  await new Promise(resolve =\u003e setTimeout(resolve, 1000));\n  // ... API 호출 로직 ...\n  return { title: 'Fetched Data on Client!' };\n}\n\nexport default function ClientComponent() {\n  // 이 코드는 이제 ssr: false 덕분에 클라이언트에서만 실행되므로 안전합니다.\n  const { data } = useSuspenseQuery({\n    queryKey: ['data'],\n    queryFn: fetchData\n  });\n\n  return \u003cdiv\u003e{data.title}\u003c/div\u003e;\n}\n```\n\n\n코드 예시를 통해 해결 방법이 얼마나 간단하고 명확한지 확인하셨을 것입니다. 이제 마지막으로 이 경험을 통해 얻을 수 있는 중요한 교훈을 정리해 보겠습니다.\n\n6. 결론: App Router 렌더링 전략의 이해\n\nuseSuspenseQuery와 클라이언트 컴포넌트 조합 사용 시 발생한 서버 행 이슈는 단순한 버그가 아닙니다. 이는 Next.js App Router가 채택한 렌더링 모델에 대한 깊은 이해가 왜 중요한지를 보여주는 매우 좋은 사례이며, 의도적인 렌더링 경계 설계의 필요성을 역설합니다.\n\n이 글을 통해 우리가 얻은 핵심 교훈은 다음과 같습니다.\n\n* 핵심 교훈 1: 'use client'는 서버 렌더링을 배제하는 지시어가 아닙니다. 이는 서버에서 사전 렌더링 후 클라이언트에서 하이드레이션하는, 즉 SSR과 CSR이 결합된 App Router의 기본 모델을 의미합니다.\n* 핵심 교훈 2: 만약 컴포넌트가 서버 환경에서는 실행되어서는 안 되는 클라이언트 전용 데이터 페칭 로직이나 API를 포함하고 있다면, next/dynamic과 ssr: false 옵션을 사용하는 것은 단순한 문제 해결이 아닌, 필수적인 아키텍처 결정입니다. 이를 통해 명확한 CSR 경계를 설정해야 합니다.\n\n이제 여러분은 Next.js의 렌더링 전략을 더 효과적으로 활용할 준비가 되었습니다. 이 글에서 다룬 원리와 해결책을 바탕으로 유사한 문제를 예방하고, 더욱 견고하고 안정적인 애플리케이션을 구축하시기를 바랍니다."])</script><script>self.__next_f.push([1,"15:T18cd,"])</script><script>self.__next_f.push([1,"\n# 프론트엔드 개발, OOP와 FP의 완벽한 조화: 실무 적용 가이드\n\n프론트엔드 개발 생태계는 빠르게 변화했습니다. 과거 UI를 클래스로 제어하던 시절을 지나, React Hooks와 Redux의 등장으로 함수형 프로그래밍(FP)의 개념이 깊숙이 자리 잡았습니다.\n\n많은 개발자가 **\"그래서 클래스를 써야 해, 함수를 써야 해?\"**라는 질문을 던집니다. 하지만 모던 프론트엔드 아키텍처의 핵심은 양자택일이 아닌 **적재적소의 조화(Harmony)**에 있습니다.\n\n이번 포스팅에서는 프론트엔드 실무에서 **객체 지향 프로그래밍(OOP)**과 **함수형 프로그래밍(FP)**을 어떻게 섞어 써야 가장 효율적인지, 구체적인 케이스와 코드를 통해 알아봅니다.\n\n---\n\n## 1. 객체 지향 프로그래밍 (OOP)\n\u003e **핵심 키워드:** 캡슐화(Encapsulation), 상태 유지, 응집도\n\nOOP는 데이터(State)와 그 데이터를 조작하는 행위(Method)를 하나의 '객체'로 묶어서 관리합니다. 프론트엔드에서 OOP가 빛을 발하는 순간은 **\"맥락(Context)을 유지해야 할 때\"**입니다.\n\n### 📌 Best Case: 외부 시스템 및 연결 관리 (Service Layer)\nAPI 클라이언트, 소켓 연결, 복잡한 인증 로직처럼 **설정값이나 연결 상태를 계속 유지해야 하는 경우** 클래스가 유리합니다.\n\n#### ❌ FP만 고집할 때의 문제점 (Prop Drilling)\n모든 함수에 토큰이나 설정값을 인자로 계속 넘겨줘야 합니다.\n\n```typescript\n// 매번 token을 인자로 받아야 함 (불편함)\nconst fetchUser = (token: string, userId: string) =\u003e {\n  return fetch(`/api/users/${userId}`, {\n    headers: { Authorization: token }\n  });\n};\n```\n\n#### ✅ OOP를 활용한 해결책 (Encapsulation)\n`ApiClient` 클래스 내부에 토큰과 Base URL을 **캡슐화**하면, 사용하는 쪽에서는 내부 구현을 신경 쓸 필요가 없습니다.\n\n```typescript\nclass ApiClient {\n  constructor(private token: string, private baseUrl: string) {}\n\n  // 설정값(token)을 내부 상태로 관리하여 응집도를 높임\n  private async request(path: string) {\n    return fetch(`${this.baseUrl}${path}`, {\n      headers: { Authorization: this.token }\n    });\n  }\n\n  getUser(userId: string) {\n    return this.request(`/users/${userId}`);\n  }\n}\n\n// 사용: 사용하는 쪽 코드가 깔끔해짐\nconst api = new ApiClient('user-token-123', 'https://api.app.com');\napi.getUser('user-1'); // 토큰을 넘길 필요 없음\n```\n\n---\n\n## 2. 함수형 프로그래밍 (FP)\n\u003e **핵심 키워드:** 순수 함수(Pure Function), 불변성(Immutability), 파이프라인\n\nFP는 부수 효과(Side-effect)를 없애고 입력이 같으면 출력도 같다는 것을 보장합니다. 프론트엔드에서 FP가 빛을 발하는 순간은 **\"데이터를 가공하고 계산할 때\"**입니다.\n\n### 📌 Best Case: 비즈니스 로직 및 데이터 변환\n서버에서 받은 데이터를 필터링하거나, 장바구니 합계를 계산하는 등의 로직은 순수 함수로 작성하는 것이 좋습니다.\n\n#### ❌ OOP 스타일의 문제점 (강한 결합)\n로직이 특정 객체의 상태(`this`)에 의존하면, 테스트하기 어렵고 다른 곳에서 재사용하기 힘듭니다.\n\n```typescript\nclass ShoppingCart {\n  private items: Product[] = [];\n  \n  // 상태와 로직이 섞여 있어 테스트가 번거로움\n  calculateTotal() {\n    return this.items.reduce((sum, item) =\u003e sum + item.price, 0);\n  }\n}\n```\n\n#### ✅ FP를 활용한 해결책 (Predictability)\n데이터 구조와 로직을 분리합니다. `calculateTotal` 함수는 오직 입력받은 배열에만 의존하므로 예측 가능하고 테스트가 쉽습니다.\n\n```typescript\n// 순수 함수: Input -\u003e Output이 명확함\nconst calculateTotal = (items: Product[]): number =\u003e {\n  const total = items.reduce((sum, item) =\u003e sum + item.price, 0);\n  // 배송비 계산 로직 등 확장에도 유연함\n  return total \u003e 30000 ? total : total + 3000;\n};\n\n// 사용: 어디서든 재사용 가능\nconst finalPrice = calculateTotal(cartItems);\n```\n\n---\n\n## 3. 결론: 하이브리드 아키텍처 (Harmony)\n\n실제 프로덕션 레벨의 프론트엔드 코드는 이 두 가지 패러다임을 혼합하여 사용합니다. React 컴포넌트는 이 둘을 이어주는 **접착제(Glue)** 역할을 수행합니다.\n\n### 💡 실무 적용 패턴 예시\n\n1.  **OOP:** 복잡한 API 통신과 설정은 `Class`로 관리합니다.\n2.  **FP:** 데이터를 화면에 보여주기 위한 가공은 `Pure Function`을 사용합니다.\n3.  **React:** 이 둘을 조합하여 UI를 렌더링합니다.\n\n```tsx\n// 1. [OOP] Service Layer 인스턴스 생성\nconst authService = new AuthService(config);\n\nconst UserList = () =\u003e {\n  const [users, setUsers] = useState([]);\n\n  useEffect(() =\u003e {\n    // [OOP] 메서드 호출: 복잡한 인증 로직은 숨겨져 있음\n    authService.getUsers().then(setUsers);\n  }, []);\n\n  // 2. [FP] 순수 함수 사용: 데이터 가공 로직 분리\n  // sortUsersByName은 외부 파일에 정의된 순수 함수라고 가정\n  const sortedUsers = useMemo(() =\u003e sortUsersByName(users), [users]);\n\n  return (\n    \u003cul\u003e\n      {/* 3. [FP] 선언적 렌더링 */}\n      {sortedUsers.map(user =\u003e (\n        \u003cli key={user.id}\u003e{user.name}\u003c/li\u003e\n      ))}\n    \u003c/ul\u003e\n  );\n};\n```\n\n### 요약: 언제 무엇을 써야 할까?\n\n| 구분 | 역할 | 추천 패러다임 | 이유 |\n| :--- | :--- | :--- | :--- |\n| **API / Service** | 데이터 페칭, 소켓, 인증 | **OOP** | 설정값과 연결 상태를 **캡슐화**하기 위해 |\n| **Business Logic** | 계산, 포맷팅, 필터링 | **FP** | **테스트 용이성**과 예측 가능성을 위해 |\n| **Store** | 전역 상태 변경 (Redux 등) | **FP** | **불변성**을 통한 상태 변경 추적을 위해 |\n| **UI Component** | 화면 렌더링 | **Hybrid** | 라이프사이클(OOP) + 렌더링 로직(FP) |\n\n프론트엔드 개발자로서 한 가지 패러다임에 갇히기보다, 각 패러다임이 가진 장점을 이해하고 상황에 맞게 골라 쓰는 유연함이 필요합니다. \n\n**\"상태 관리는 OOP처럼, 데이터 처리는 FP처럼.\"** 이 원칙을 기억하면 더 견고한 애플리케이션을 설계할 수 있을 것입니다.\n"])</script><script>self.__next_f.push([1,"16:T13dd,"])</script><script>self.__next_f.push([1,"\n# 무조건적인 가상화(Virtualization) 도입, 과연 정답일까? (feat. content-visibility)\n\n프론트엔드 개발자라면 긴 리스트를 다룰 때 습관적으로 **\"가상화(Virtualization)를 도입해야겠다\"**고 생각합니다. `react-window`나 `tanstack-virtual` 같은 라이브러리를 설치하는 것이 일종의 'Best Practice'처럼 여겨지죠.\n\n하지만 10년 차 프론트엔드 개발자로서 수많은 프로젝트를 거치며 깨달은 점은, **가상화는 공짜 점심이 아니라는 사실**입니다. 가상화는 성능을 얻는 대신 **UX(사용자 경험)**를 비용으로 지불합니다.\n\n오늘은 리스트 렌더링 성능 최적화의 본질적인 원리와, 가상화가 가진 UX 결함, 그리고 이를 대체할 수 있는 모던 CSS 전략(`content-visibility`)에 대해 이야기해보려 합니다.\n\n---\n\n## 1. 우리는 왜 가상화를 하는가? (본질적인 병목)\n\n데이터가 수천, 수만 개로 늘어날 때 브라우저가 느려지는 진짜 이유는 무엇일까요? 단순히 \"데이터가 많아서\"가 아닙니다.\n\n### DOM 개수의 비대화와 선형적 성능 저하\n가장 큰 문제는 DOM 노드의 개수입니다. 리스트 아이템이 1만 개이고, 각 아이템이 10개의 태그를 가진다면 브라우저는 **10만 개의 DOM 노드**를 메모리에 올리고 관리해야 합니다.\n\n문제는 사용자가 스크롤을 내려 페이지가 쌓일수록 성능 저하가 **선형적(Linear)**으로 발생한다는 점입니다.\n* **Recalculate Style 비용 증가:** 버튼 하나를 클릭해 상태가 바뀌어도, 브라우저는 거대해진 DOM 트리를 순회하며 스타일 계산을 다시 해야 합니다.\n* **메모리 누수:** 화면 밖으로 지나간 수천 개의 이미지와 컴포넌트들이 메모리(RAM/VRAM)를 계속 점유합니다.\n\n가상화(Virtualization)는 이 문제를 해결하기 위해 **\"보이는 영역(Viewport)만 렌더링하고, 벗어난 영역은 DOM에서 제거\"**하는 기술입니다. 덕분에 데이터가 100만 개여도 DOM 노드는 항상 20개 내외로 유지됩니다.\n\n---\n\n## 2. 오해: \"스크롤하면 리페인트(Repaint)가 발생해서 느리다?\"\n\n많은 개발자가 *\"DOM이 많으면 스크롤할 때마다 리페인트가 발생해서 느리다\"*고 오해합니다. 결론부터 말하면 **최신 브라우저에서 최적화된 네이티브 스크롤은 리페인트를 유발하지 않습니다.**\n\n### 브라우저의 스크롤 동작 원리 (Pixel Pipeline)\n1.  **Composite Only:** 브라우저는 스크롤 가능한 영역을 별도의 **레이어(Layer)**로 승격(Promote)시킵니다.\n2.  **GPU 가속:** 이미 그려진(Paint 완료된) 비트맵 텍스처를 GPU가 좌표만 이동시킵니다.\n3.  **결과:** Layout과 Paint 단계를 건너뛰고 **Composite** 단계만 수행하므로 매우 부드럽습니다.\n\n### 그렇다면 가상화 없는 1만 개 리스트는 왜 버벅거릴까?\n리페인트 때문이 아니라, 다른 연산 비용 때문입니다.\n1.  **Hit Testing 과부하:** 스크롤 중 마우스 커서 아래에 어떤 요소가 있는지(Hover, Event 등) 계산해야 하는데, DOM이 1만 개면 이 탐색 비용이 16ms(60fps)를 초과합니다.\n2.  **GPU 대역폭 한계:** 1만 개 분량의 거대한 텍스처를 타일링(Tiling)하고 GPU 메모리로 전송하는 과정에서 병목이 발생합니다.\n3.  **GC(가비지 컬렉션):** 수많은 DOM 노드 참조로 인해 GC 수행 시간이 길어져 스크롤이 턱턱 걸리게 됩니다.\n\n아이러니하게도, **가상화를 적용하면 스크롤할 때마다 필연적으로 리페인트가 발생**합니다. JS가 DOM을 계속 갈아 끼우기 때문이죠. 하지만 \"전체 DOM을 유지하는 비용\"보다 \"작은 영역을 계속 다시 그리는 비용\"이 훨씬 싸기 때문에 가상화를 쓰는 것입니다.\n\n---\n\n## 3. 가상화의 치명적인 단점 (UX Trade-offs)\n\n성능을 위해 가상화를 도입하면 다음과 같은 UX 손해를 감수해야 합니다.\n\n1.  **Ctrl + F (검색) 불가:** DOM에 요소가 없으니 브라우저 기본 찾기 기능으로 내용을 찾을 수 없습니다.\n2.  **스크롤 이질감:** 네이티브 스크롤의 관성, 바운스 등을 JS로 흉내 내야 하므로 미묘하게 어색합니다.\n3.  **스크롤바 널뛰기:** 동적 높이(Dynamic Height) 아이템일 경우, 스크롤바가 떨리거나 위치가 튀는 현상이 발생합니다.\n4.  **빈 화면(White Space):** 스크롤 속도가 렌더링 속도보다 빠르면 하얀 빈 공간이 보입니다.\n\n---\n\n## 4. 현실적인 대안: CSS `content-visibility`\n\n\"데이터가 100~200개 정도인데 가상화를 써야 할까?\"\n이런 고민이 든다면, 가상화는 오버엔지니어링일 확률이 높습니다. 이때 사용할 수 있는 강력한 대안이 CSS의 **`content-visibility: auto`** 입니다.\n\n```css\n.list-item {\n  content-visibility: auto;\n  contain-intrinsic-size: 100px; /* 아이템의 예상 높이 */\n}\n\n```\n"])</script><script>self.__next_f.push([1,"17:T1f43,"])</script><script>self.__next_f.push([1,"\n# [Architecture] NPM 패키지 분리 환경에서 싱글톤(Singleton) 유지하기: globalThis와 Symbol.for의 활용\n\n최근 사내 패키지 배포 구조를 개선하면서 마주친 문제와 그 해결 과정을 공유합니다.\n\n여러 프로젝트에서 공통으로 사용하는 패키지들을 npm 저장소(Nexus 등)에 배포하여 관리하고 있는데, 배포 편의성을 위해 의존성 패키지를 번들(Bundle)에 포함시키는 과정에서 **싱글톤(Singleton) 객체가 유지되지 않는 이슈**가 발생했습니다.\n\n이 글에서는 물리적으로 분리된 번들 환경에서 어떻게 안전하게 싱글톤 인스턴스를 공유했는지, 그 과정에서 **`globalThis`**와 **`Symbol.for`**를 어떻게 활용했는지 다룹니다.\n\n## 1. 문제 상황 (The Problem)\n\n### 아키텍처 구조\n현재 우리 팀은 다음과 같은 3가지 패키지를 운용하고 있습니다.\n\n* **Framework**: 핵심 로직과 싱글톤 객체(Store, Manager 등)를 제공\n* **Editor**: `Framework`를 의존하여 사용하는 편집 도구\n* **Converter**: `Framework`를 의존하여 사용하는 변환 도구\n\n배포 및 설치 편의성을 위해 `Editor`와 `Converter`를 배포할 때, 이들이 의존하는 `Framework` 코드를 각각의 번들에 포함(Bundled)시켜 배포했습니다.\n\n### 발생한 이슈\n호스트 애플리케이션에서 `Editor`와 `Converter`를 동시에 설치해서 사용할 때 문제가 발생했습니다.\n\n1.  `Editor`가 로드되면서 내부의 `Framework`가 초기화됨 (싱글톤 A 생성)\n2.  `Converter`가 로드되면서 내부의 `Framework`가 초기화됨 (싱글톤 B 생성)\n3.  **결과:** 두 패키지가 **서로 다른 싱글톤 인스턴스**를 바라보게 되어 상태 공유가 불가능해짐.\n\n## 2. 원인 분석\n\n일반적인 ES Module 시스템에서 싱글톤은 **모듈 스코프(Module Scope)** 내의 클로저를 통해 유지됩니다.\n\n하지만 번들링을 하게 되면 각 번들 파일(`editor.bundle.js`, `converter.bundle.js`)마다 `Framework`의 코드가 복제되어 들어갑니다. 자바스크립트 런타임 입장에서 이 두 코드는 **서로 다른 물리적 모듈**로 취급되므로, 각각 별도의 실행 컨텍스트와 메모리 공간을 갖게 됩니다.\n\n따라서 모듈 시스템의 스코프를 넘어선 **전역 공간(Global Scope)**을 통한 상태 공유가 필요했습니다.\n\n## 3. 해결 전략: Global Scope 활용\n\n### 1차 접근: 전역 객체(globalThis) 사용\n브라우저와 Node.js 환경 모두를 아우를 수 있는 표준인 `globalThis`에 인스턴스를 저장하기로 했습니다.\n\n```typescript\n// 단순히 문자열 키를 사용한다면?\nglobalThis['MY_FRAMEWORK_INSTANCE'] = new Framework();\n```\n\n하지만 단순히 문자열 키(`string key`)를 사용하는 것은 다음과 같은 위험이 있습니다.\n* **이름 충돌:** 다른 라이브러리나 레거시 코드에서 우연히 같은 이름을 사용할 경우 덮어씌워질 위험이 있음.\n* **전역 오염:** `Object.keys(window)` 등으로 조회했을 때 노출되어, 의도치 않은 접근이나 수정이 발생할 수 있음.\n\n### 2차 접근: Symbol.for() 활용 (최종 솔루션)\n이 문제를 해결하기 위해 **`Symbol.for()`**를 사용했습니다.\n\n* **Namespace 격리:** Symbol은 일반 문자열 키와 다른 레이어에 저장되므로, 일반적인 전역 변수 접근으로 오염될 일이 없습니다.\n* **Cross-Realm 공유:** `Symbol()`은 호출할 때마다 매번 다른 값을 만들지만, `Symbol.for('key')`는 **전역 심볼 레지스트리**를 통해 키가 같으면 동일한 심볼 객체를 반환합니다. 즉, **번들이 달라도 같은 심볼을 가리킬 수 있습니다.**\n\n## 4. 구현 코드 (Implementation)\n\n기존의 싱글톤 레지스트리 패턴에 `globalThis`와 `Symbol.for`를 적용한 구현입니다.\n\n### SingletonRegistry.ts\n\n```typescript\n// 1. 전역에서 유일성을 보장하기 위한 Symbol 키 생성\n// 충돌 방지를 위해 회사 도메인 등을 포함한 긴 네이밍 권장\nconst CONSTRUCTORS_KEY = Symbol.for('my-org.framework.registry.constructors');\nconst SINGLETONS_KEY = Symbol.for('my-org.framework.registry.singletons');\n\n// 2. 전역 객체 타입 정의 (TypeScript)\ntype GlobalWithRegistry = typeof globalThis \u0026 {\n  [CONSTRUCTORS_KEY]?: Map\u003cstring, new (...args: any[]) =\u003e any\u003e;\n  [SINGLETONS_KEY]?: Map\u003cstring, any\u003e;\n};\n\n// 3. 전역 맵 접근 헬퍼 (초기화 로직 포함)\nfunction getGlobalSingletons(): Map\u003cstring, any\u003e {\n  const g = globalThis as GlobalWithRegistry;\n  if (!g[SINGLETONS_KEY]) {\n    g[SINGLETONS_KEY] = new Map();\n  }\n  return g[SINGLETONS_KEY]!;\n}\n\n// ... 생성자 맵 접근 함수도 동일한 방식 ...\n\nexport namespace SingletonRegistry {\n  export const register = (name: string, constructor: new (...args: any[]) =\u003e any) =\u003e {\n    // 로컬 변수가 아닌 전역 심볼 맵에 저장\n    getGlobalConstructors().set(name, constructor);\n  };\n\n  export const resolve = (name: string) =\u003e {\n    const singletons = getGlobalSingletons();\n    \n    // 이미 생성된 인스턴스가 전역 맵에 있는지 확인\n    if (!singletons.has(name)) {\n      const constructors = getGlobalConstructors();\n      const constructor = constructors.get(name);\n      \n      if (!constructor) {\n        throw new Error(`Singleton ${name} is not registered`);\n      }\n      \n      // 인스턴스 생성 후 전역 맵에 저장 -\u003e 다른 번들에서도 이 인스턴스를 보게 됨 \n      singletons.set(name, new constructor());\n    }\n\n    return singletons.get(name);\n  };\n}\n```\n\n이렇게 구현하면 `Editor` 번들에서 먼저 `resolve`를 호출해 인스턴스를 만들면, 나중에 로드된 `Converter` 번들에서도 `globalThis`의 심볼 키를 통해 **동일한 인스턴스**를 찾아 반환하게 됩니다.\n\n## 5. 주의사항 및 한계 (Trade-offs)\n\n이 방식은 유용한 \"탈출구(Escape Hatch)\"이지만, 몇 가지 주의할 점이 있습니다.\n\n### 1) `instanceof` 체크 불가\n서로 다른 번들에서 로드된 클래스는 내용은 같아도 자바스크립트 엔진상 **다른 생성자 함수**입니다. 따라서 `resolve()`로 가져온 객체에 대해 `instanceof` 검사를 하면 `false`가 나올 수 있습니다.\n* **해결:** 타입 체크가 필요하다면 `instanceof` 대신 **Duck Typing**이나 공통 **Interface**를 사용해야 합니다.\n\n### 2) 버전 관리 (Version Mismatch)\n만약 `Editor`는 Framework v1.0을, `Converter`는 Framework v2.0을 번들링하고 있다면 런타임 에러가 발생할 수 있습니다. (v1 인스턴스가 전역에 있는데 v2 메서드를 호출하는 경우 등)\n* **해결:** 모든 패키지가 동일한 버전의 Framework를 사용하도록 CI 단계에서 엄격하게 관리하거나, 심볼 키에 버전을 명시(`Symbol.for('...v1')`)하여 격리해야 합니다.\n\n### 3) 테스트 격리\n단위 테스트(Jest/Vitest) 실행 시 `globalThis`가 오염되어 테스트 간 간섭이 발생할 수 있습니다. `afterEach` 등에서 전역 심볼 맵을 초기화해주는 작업이 필요합니다.\n\n## 6. 결론\n\nNPM 패키지 배포 시 번들링 전략에 따라 싱글톤 패턴이 깨지는 문제는 흔히 발생할 수 있습니다. 가장 정석적인 방법은 `peerDependencies`를 사용하여 호스트가 단일 버전을 설치하게 하는 것이지만, 배포 및 사용 편의성을 위해 번들링이 필수적인 상황이라면 **`globalThis`와 `Symbol.for`를 활용한 전역 레지스트리 패턴**이 훌륭한 해결책이 될 수 있습니다.\n\n이 패턴은 React, Styled-components 등 유명 라이브러리들에서도 런타임 환경의 제약을 극복하기 위해 내부적으로 사용하는 검증된 방식입니다. 다만, 사용 시 발생할 수 있는 사이드 이펙트(버전, 타입 체크)를 충분히 인지하고 적용해야 합니다.\n"])</script><script>self.__next_f.push([1,"3:[\"$\",\"$Lf\",null,{\"posts\":[{\"title\":\"🚀 Gemini CLI 완벽 가이드: 터미널에서 Gemini 모델 활용하기\",\"summary\":\"Gemini CLI를 설치하고 설정하는 방법부터 Slash, At, Shell 명령어 사용법, 팁과 활용 예시까지 완벽하게 안내합니다.\",\"tags\":[\"Gemini\",\"CLI\",\"AI\",\"터미널\",\"개발\"],\"date\":\"2025-12-21\",\"id\":\"gemini-cli-get-started\",\"content\":\"$10\"},{\"title\":\"Giscus: 광고 없는 무료 댓글 시스템, 5분 만에 적용하기\",\"summary\":\"Giscus는 GitHub Discussions API를 활용하여 광고 없이 깔끔한 디자인과 마크다운을 지원하는 무료 댓글 시스템으로, 개발 블로그에 쉽게 적용할 수 있습니다.\",\"tags\":[\"Giscus\",\"댓글 시스템\",\"GitHub Discussions\",\"개발 블로그\",\"무료\"],\"date\":\"2025-12-21\",\"id\":\"giscus\",\"content\":\"$11\"},{\"title\":\"[Tip] RSS란 무엇인가? 내 기술 블로그에 RSS 달고 Feedly로 구독하기\",\"date\":\"2025-12-21\",\"tags\":[\"RSS\",\"Blog\",\"Tip\"],\"summary\":\"RSS의 개념과 GitHub Pages 블로그에 RSS를 적용하는 방법, Feedly 사용법을 알아봅니다.\",\"id\":\"rss\",\"content\":\"$12\"},{\"title\":\"Datadog vs Sentry: 우리 팀에 맞는 모니터링 툴은 무엇일까?\",\"summary\":\"Datadog과 Sentry의 특징과 장단점을 비교하여 팀의 상황에 맞는 최적의 모니터링 도구를 선택하는 방법을 알아봅니다.\",\"tags\":[\"Datadog\",\"Sentry\",\"Monitoring\",\"APM\",\"RUM\"],\"date\":\"2025-12-21\",\"id\":\"sentry-vs-datadog\",\"content\":\"$13\"},{\"title\":\"Next.js App Router: useSuspenseQuery 서버 행(Hanging) 이슈 해결\",\"date\":\"2025-12-20\",\"tags\":[\"Next.js\",\"React Query\",\"App Router\"],\"summary\":\"App Router에서 useSuspenseQuery 사용 시 발생하는 서버 행 현상의 원인을 파헤치고 next/dynamic을 통한 해결책을 제시합니다.\",\"id\":\"app-router-useSuspenseQuery\",\"content\":\"$14\"},{\"title\":\"프론트엔드 OOP와 FP 조화: 실무 적용 완벽 가이드\",\"summary\":\"프론트엔드 개발에서 객체 지향 프로그래밍(OOP)과 함수형 프로그래밍(FP)을 조화롭게 사용하여 효율적인 아키텍처를 구축하는 방법을 알아봅니다.\",\"tags\":[\"frontend\",\"OOP\",\"FP\",\"architecture\",\"javascript\"],\"date\":\"2025-12-20\",\"id\":\"frontend-oop-fp\",\"content\":\"$15\"},{\"title\":\"가상화(Virtualization) 도입, 과연 정답일까? (feat. content-visibility)\",\"summary\":\"가상화의 성능상 이점과 UX상의 단점을 살펴보고, content-visibility를 이용한 대안을 제시합니다.\",\"tags\":[\"virtualization\",\"performance\",\"css\",\"content-visibility\",\"frontend\"],\"date\":\"2025-12-20\",\"id\":\"scroll-virtualization\",\"content\":\"$16\"},{\"title\":\"NPM 패키지 분리 환경에서 싱글톤(Singleton) 유지하기: globalThis와 Symbol.for의 활용\",\"summary\":\"물리적으로 분리된 번들 환경에서 globalThis와 Symbol.for를 활용하여 싱글톤 인스턴스를 안전하게 공유하는 방법을 설명합니다.\",\"tags\":[\"NPM\",\"Singleton\",\"globalThis\",\"Symbol.for\",\"JavaScript\"],\"date\":\"2025-12-20\",\"id\":\"singleton-in-package\",\"content\":\"$17\"},{\"title\":\"Folder Structure Test Post\",\"date\":\"2020-12-21\",\"tags\":[\"Test\",\"Structure\"],\"summary\":\"This is a test post to verify folder-based structure and image loading.\",\"id\":\"folder-test-post\",\"content\":\"\\nThis is a post inside a folder.\\n\\nHere is an image:\\n![Test Image](./image.png)\\n\\nAnd some text below.\\n\\n\"}]}]\n"])</script><script>self.__next_f.push([1,"8:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"meta\",\"1\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}]]\n"])</script><script>self.__next_f.push([1,"6:null\n"])</script><script>self.__next_f.push([1,"a:[[\"$\",\"title\",\"0\",{\"children\":\"Dev-Holic Blog\"}],[\"$\",\"meta\",\"1\",{\"name\":\"description\",\"content\":\"Dev-Holic Blog - Tech, Development, and more\"}],[\"$\",\"meta\",\"2\",{\"property\":\"og:title\",\"content\":\"Dev-Holic Blog\"}],[\"$\",\"meta\",\"3\",{\"property\":\"og:description\",\"content\":\"Tech, Development, and more\"}],[\"$\",\"meta\",\"4\",{\"property\":\"og:url\",\"content\":\"https://dev-holic.github.io\"}],[\"$\",\"meta\",\"5\",{\"property\":\"og:site_name\",\"content\":\"Dev-Holic Blog\"}],[\"$\",\"meta\",\"6\",{\"property\":\"og:locale\",\"content\":\"ko_KR\"}],[\"$\",\"meta\",\"7\",{\"property\":\"og:image:alt\",\"content\":\"Dev-Holic Blog\"}],[\"$\",\"meta\",\"8\",{\"property\":\"og:image:type\",\"content\":\"image/png\"}],[\"$\",\"meta\",\"9\",{\"property\":\"og:image\",\"content\":\"https://dev-holic.github.io/opengraph-image?3ae57bf970b1b170\"}],[\"$\",\"meta\",\"10\",{\"property\":\"og:image:width\",\"content\":\"1200\"}],[\"$\",\"meta\",\"11\",{\"property\":\"og:image:height\",\"content\":\"630\"}],[\"$\",\"meta\",\"12\",{\"property\":\"og:type\",\"content\":\"website\"}],[\"$\",\"meta\",\"13\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"$\",\"meta\",\"14\",{\"name\":\"twitter:title\",\"content\":\"Dev-Holic Blog\"}],[\"$\",\"meta\",\"15\",{\"name\":\"twitter:description\",\"content\":\"Tech, Development, and more\"}],[\"$\",\"meta\",\"16\",{\"name\":\"twitter:image:alt\",\"content\":\"Dev-Holic Blog\"}],[\"$\",\"meta\",\"17\",{\"name\":\"twitter:image:type\",\"content\":\"image/png\"}],[\"$\",\"meta\",\"18\",{\"name\":\"twitter:image\",\"content\":\"https://dev-holic.github.io/opengraph-image?3ae57bf970b1b170\"}],[\"$\",\"meta\",\"19\",{\"name\":\"twitter:image:width\",\"content\":\"1200\"}],[\"$\",\"meta\",\"20\",{\"name\":\"twitter:image:height\",\"content\":\"630\"}]]\n"])</script></body></html>