1:"$Sreact.fragment"
2:I[91320,["/_next/static/chunks/c6311bd1204a06f2.js","/_next/static/chunks/e8cd9421287ba6e3.js","/_next/static/chunks/c8696c5ee1a86c19.js"],"PostList"]
a:I[97990,["/_next/static/chunks/28ff6a04602448ba.js","/_next/static/chunks/64c697a3cb51cd07.js"],"OutletBoundary"]
b:"$Sreact.suspense"
3:T169c,
개발팀이 성장하고 서비스 규모가 커지면 필연적으로 **'모니터링(Monitoring)'**에 대한 니즈가 발생합니다. 시장에는 수많은 툴이 있지만, 가장 대표적인 두 가지를 꼽자면 단연 **Datadog(데이터독)**과 **Sentry(센트리)**일 것입니다.

흔히 "둘 다 모니터링 툴 아니야?"라고 생각하기 쉽지만, 두 서비스는 **태생과 지향점**이 완전히 다릅니다. 이번 포스팅에서는 클라이언트, 서버 로깅, APM, RUM, 대시보드 구성 등을 기준으로 두 툴을 상세 비교하고, 어떤 상황에서 무엇을 선택해야 할지 정리해 보았습니다.

## 1. 핵심 철학의 차이: 관제실 vs 현미경

두 툴의 가장 큰 차이는 **'누구를 위해 만들어졌는가'**입니다.

* **Datadog:** 인프라 엔지니어와 DevOps를 위한 **통합 관제실**. 숲을 보고 시스템 전체의 이상 징후를 감지하는 데 특화되어 있습니다.
* **Sentry:** 애플리케이션 개발자를 위한 **디버깅 툴**. 나무를 보고 코드의 몇 번째 줄에서 에러가 났는지 분석하는 데 특화되어 있습니다.

---

## 2. 기능별 상세 비교

### ① 로깅 및 에러 트래킹 (Client & Server)

이 영역은 두 툴의 정체성이 가장 극명하게 갈리는 부분입니다.

| 구분 | Sentry (개발자 중심) | Datadog (운영자 중심) |
| :--- | :--- | :--- |
| **Client (FE/App)** | **압도적 우위.** Source Map을 통해 난독화된 코드의 정확한 위치를 집어줍니다. Breadcrumbs로 유저의 이동 경로 추적이 가능합니다. | 로그 수집은 가능하나, 프론트엔드 디버깅을 위한 직관적인 정보(Stack trace 시각화 등)는 부족합니다. |
| **Server Logging** | **Exception 중심.** 에러가 발생한 시점의 콜 스택 분석에 강력합니다. 단순 Info 로그를 쌓기엔 적합하지 않습니다. | **Log Management 강자.** 수십 기가의 로그를 쌓아두고 검색(Grep), 필터링, 시각화하는 능력이 탁월합니다. |
| **Grouping** | 같은 에러를 지능적으로 하나로 묶어주는 기능이 매우 뛰어납니다. | 패턴으로 묶을 수 있으나 Sentry만큼 정교한 이슈 관리는 어렵습니다. |

> **Key Point:** 프론트엔드/백엔드 **코드의 버그를 잡으려면 Sentry**가 필수적이고, 서버의 **전반적인 로그(접속 로그, 시스템 로그 등)를 관리하려면 Datadog**이 필요합니다.

### ② APM (Application Performance Monitoring)

* **Sentry:** **트랜잭션 중심**입니다. "이 API 호출이 왜 느리지?"를 코드 레벨에서 파고듭니다. 특정 함수나 DB 쿼리의 병목을 찾는 데 유용하며 설정이 비교적 간편합니다.
* **Datadog:** **인프라 + 트랜잭션**입니다. 코드 병목뿐만 아니라 CPU, 메모리, 네트워크, 디스크 I/O 등 인프라 지표와 연관 지어 분석합니다. 특히 MSA 환경에서 수십 개의 서비스가 얽혀있을 때의 **Service Map** 시각화 능력은 업계 표준 수준입니다.

### ③ RUM (Real User Monitoring) & Session Replay

* **Sentry:** **디버깅을 위한 UX 분석**에 가깝습니다. Core Web Vitals(LCP, FID) 측정에 충실하며, **Session Replay** 기능을 통해 유저가 에러를 겪은 순간의 화면을 녹화해서 보여줍니다. 이는 버그 재현에 엄청난 도움을 줍니다.
* **Datadog:** **비즈니스 인사이트 도출**까지 가능합니다. 사용자의 지역, 기기, 네트워크 상태 등 방대한 데이터를 수집합니다. Session Replay도 제공하지만, UX 분석 툴(Hotjar 등) 수준의 디테일과 마케팅적 데이터를 제공하는 대신 비용이 비쌉니다.

### ④ 대시보드 구성 (Customizability)

* **Sentry:** **낮은 자유도.** "할 일 목록(To-Do List)"에 가깝습니다. 이슈 목록, 릴리즈 현황 등 Sentry가 제공하는 뷰를 따라야 합니다. 개발자가 에러를 처리하는 워크플로우에 최적화되어 있습니다.
* **Datadog:** **높은 자유도.** NASA 관제실 같은 대시보드를 만들 수 있습니다. 로그 수, CPU 사용량, 심지어 매출액까지 원하는 모든 지표를 위젯으로 만들어 한 화면에 구성할 수 있습니다.

---

## 3. 가격 (Cost)

현실적으로 가장 중요한 부분입니다.

* **Sentry:** 상대적으로 합리적이고 예측 가능합니다. (사용자 수 + 이벤트 수 기반)
* **Datadog:** **비쌉니다.** 호스트 당, 로그 용량 당, APM 호스트 당, RUM 세션 당 과금이 따로 붙습니다. 자칫하면 요금 폭탄을 맞을 수 있어 핀옵스(FinOps) 관점의 관리가 필요합니다.

---

## 4. 결론: 무엇을 선택해야 할까?

### Sentry를 먼저 도입하세요, 만약...
* 서비스 초기~중기 단계이다.
* **프론트엔드(Web/App)** 의 비중이 크고 사용자 경험이 중요하다.
* "서버가 죽는 것"보다 "기능이 동작 안 하는 버그"가 더 큰 문제다.
* 개발자가 직접 모니터링하고 코드를 수정한다.

### Datadog이 필요합니다, 만약...
* 트래픽이 많고 **MSA(Microservices)** 구조로 인프라가 복잡하다.
* DevOps/SRE 팀이 별도로 존재한다.
* 비용보다 **안정성과 통합 관제**가 최우선이다.
* 규정상 로그를 장기간 보존하고 검색해야 한다.

### 💡 Best Practice
사실 예산이 허락한다면 **두 가지를 같이 쓰는 것이 가장 이상적**입니다.

* **Frontend & App:** Sentry (에러 잡기, 화면 녹화)
* **Backend & Infra:** Datadog (서버 상태, APM, 대량 로그)

각 툴의 강점이 명확한 만큼, 팀의 상황과 목적에 맞춰 적절한 도구를 선택하시길 바랍니다.
4:T29be,
1. 서론: 끝나지 않는 로딩의 미스터리

Next.js App Router는 서버 컴포넌트와 클라이언트 컴포넌트의 유연한 조합을 통해 강력한 웹 애플리케이션 구축을 가능하게 합니다. 하지만 이 새로운 렌더링 패러다임은 강력한 만큼, 기존의 클라이언트 중심 멘탈 모델과 충돌하며 흔한 함정을 만들어냅니다. 그 대표적인 사례가 바로 @tanstack/react-query의 useSuspenseQuery를 클라이언트 컴포넌트에서 사용했을 때 발생하는 '서버 행(Hanging)' 현상, 즉 페이지 응답이 멈추고 무한 로딩에 빠지는 문제입니다.

이 글은 이 문제를 단순한 버그가 아닌, 서버 우선 렌더링 모델과 클라이언트 데이터 페칭 패턴이 충돌할 때 발생하는 예측 가능한 결과로 분석합니다. 우리는 이 현상의 근본 원인을 명확히 파헤치고, next/dynamic을 활용해 의도적인 렌더링 경계를 설정하는 확실한 해결책을 제시할 것입니다. 이제 문제 상황을 구체적으로 재현하며 본격적인 분석을 시작하겠습니다.

2. 문제 현상 분석: useSuspenseQuery가 서버를 멈추게 할 때

모든 문제 해결의 첫걸음은 현상을 명확하게 정의하고 재현하는 것입니다. 정확한 진단 없이는 올바른 처방을 내릴 수 없기 때문입니다. 어떤 환경과 코드 구조에서 이 문제가 발생하는지 구체적으로 살펴보겠습니다.

문제는 다음과 같은 시나리오에서 발생합니다.

* 환경: Next.js App Router
* 구조: 서버 컴포넌트(Server Component)가 `<Suspense>` fallback UI로 클라이언트 컴포넌트(Client Component)를 감싸는 구조
* 핵심 원인: 감싸진 클라이언트 컴포넌트 내부에서 @tanstack/react-query의 useSuspenseQuery를 호출함

이 조건들이 충족될 때 나타나는 가장 명백한 증상은 다음과 같습니다. 페이지 응답이 완료되지 않고 브라우저 탭의 파비콘이 계속 로딩 상태로 남아있는 '서버 행(Hanging)' 현상이 발생합니다. 사용자는 아무런 콘텐츠도 보지 못한 채 끝없이 기다리게 되고, 개발자 도구의 네트워크 탭을 봐도 응답이 오지 않는 것을 확인할 수 있습니다.

이처럼 서버가 응답을 멈추는 현상은 왜 발생하는 것일까요? 이 근본적인 원인을 파헤치기 위해서는, 우리가 흔히 오해하는 클라이언트 컴포넌트의 렌더링 방식에 대한 정확한 이해가 필요합니다.

3. 근본 원인 탐구: 'use client'의 오해와 진실

단순히 현상을 해결하는 것을 넘어, Next.js App Router의 핵심 렌더링 메커니즘을 이해하는 것은 매우 중요합니다. 이번 문제의 근원은 바로 'use client' 지시어에 대한 흔한 오해에서 비롯됩니다.

'use client'는 CSR을 의미하지 않는다

많은 개발자가 'use client' 지시어를 파일 상단에 추가하면 해당 컴포넌트가 오직 브라우저에서만 렌더링(Client-Side Rendering, CSR)될 것이라고 생각합니다. 하지만 이는 사실이 아닙니다. 이 동작은 Next.js에 국한된 것이 아니라, React 18의 Suspense 기반 SSR의 고유한 특성입니다. 'use client'의 정확한 의미는 다음과 같습니다.

* Pre-rendering (사전 렌더링): 'use client'로 명시된 컴포넌트조차도, 최초 페이지 로드 시에는 서버에서 초기 HTML 뼈대를 미리 렌더링(Server-Side Rendering, SSR)합니다.
* Hydration (하이드레이션): 이후 브라우저에서 JavaScript 번들이 로드되면, 서버가 생성한 HTML 위에 이벤트 핸들러 등을 연결하여 상호작용이 가능한 완전한 컴포넌트로 '깨우는' 과정을 거칠니다.

즉, 별도의 설정이 없는 한 모든 클라이언트 컴포넌트는 서버에서 최소 한 번 실행됩니다. 바로 이 지점이 useSuspenseQuery가 서버 행을 유발하는 원인입니다. 그 메커니즘은 다음과 같습니다.

1. 서버 렌더링 시도: 사용자가 페이지에 접속하면, Next.js 서버는 UI를 구성하는 클라이언트 컴포넌트의 최초 HTML 렌더링을 시도합니다.
2. 데이터 부재와 Suspend: 서버 환경에는 react-query가 관리하는 클라이언트 측 캐시 데이터가 존재하지 않습니다. 따라서 useSuspenseQuery는 데이터를 가져오기 위해 Promise를 던지고(throw), 컴포넌트를 'Suspend(일시 중단)' 상태로 만듭니다.
3. 무한 대기: 서버에 있는 부모 `<Suspense>` 경계가 이 Promise를 감지합니다. 이는 Next.js 서버의 렌더러에게 "이 부분의 HTML 생성을 중단하고 Promise가 해결될 때까지 기다려라"는 신호입니다. 하지만 이 Promise는 클라이언트 사이드 데이터 페칭 로직이므로 서버에서는 절대 해결될 수 없습니다. 결과적으로, Next.js 서버의 응답 스트림 전송이 중단된 채 무기한 대기하게 되는 '행(Hanging)' 상태에 빠집니다.

결국 문제의 원인은 클라이언트에서만 실행되어야 할 데이터 페칭 로직이 서버 렌더링 과정 중 시도되었기 때문입니다. 이를 해결하기 위한 전략은 명확합니다. 해당 컴포넌트의 서버 렌더링 자체를 의도적으로 비활성화하는 것입니다.

4. 해결책 제시: next/dynamic과 ssr: false 옵션

문제의 원인이 서버 렌더링 시도에 있다는 것을 파악했으니, 이제 명확한 해결책을 제시할 차례입니다. 우리는 해당 컴포넌트를 기본 SSR/Hydration 모델에서 의도적으로 제외하고, 순수한 클라이언트 사이드 렌더링(CSR) 경계를 설정해야 합니다.

이때 사용할 수 있는 가장 강력한 도구가 바로 Next.js의 내장 기능인 next/dynamic입니다. next/dynamic은 컴포넌트를 동적으로 임포트하게 해주며, 특히 ssr: false 옵션과 함께 사용될 때 이 문제의 완벽한 해결책이 됩니다.

ssr: false 옵션의 역할은 매우 직관적입니다. 이것은 Next.js 서버에게 **"이 컴포넌트의 HTML은 미리 만들지 말고, 브라우저에서 JavaScript가 로드된 후에 렌더링을 시작하라"**고 명확히 지시하는 것과 같습니다.

이 해결책을 적용했을 때 얻게 되는 결과는 다음과 같습니다.

* 서버는 해당 컴포넌트의 렌더링을 완전히 건너뛰고 나머지 페이지의 HTML을 구성하여 즉시 클라이언트에 응답을 보냅니다.
* 클라이언트(브라우저)는 초기 HTML을 받은 후, 해당 컴포넌트의 JavaScript 코드를 비동기적으로 로드합니다.
* 로드가 완료되면, 실제 데이터 페칭(useSuspenseQuery)과 렌더링은 온전히 클라이언트 환경에서만 일어나므로 서버 행 이슈가 근본적으로 해결됩니다.

이론적 설명을 마쳤으니, 이제 실제 코드를 통해 이 해결책을 어떻게 적용하는지 구체적으로 살펴보겠습니다.

5. 적용 코드 예시: 문제 해결의 실제

앞서 설명한 해결책을 실제 코드에 어떻게 적용하는지 보여드리겠습니다. 부모인 서버 컴포넌트에서 useSuspenseQuery를 사용하는 자식 클라이언트 컴포넌트를 불러오는 방식을 어떻게 변경하는지 집중해서 보시기 바랍니다.

먼저 부모 컴포넌트인 **ServerComponent.tsx**의 변경 사항입니다. import 구문을 next/dynamic으로 대체하고 ssr: false 옵션을 추가합니다.

```typescript
// ServerComponent.tsx (부모 컴포넌트)
import dynamic from 'next/dynamic';

// 핵심: ssr: false 옵션으로 서버 렌더링을 비활성화
const ClientComponentWithNoSSR = dynamic(
  () => import('./ClientComponent'),
  {
    ssr: false,
    // 컴포넌트의 JS가 로드되는 동안 보여줄 UI
    loading: () => <p>Loading...</p>,
  }
);

export default function Page() {
  return (
    <div>
      <h1>My Page</h1>
      {/* 서버 행 이슈 없이 클라이언트에서만 렌더링됩니다. */}
      <ClientComponentWithNoSSR />
    </div>
  );
}
```


다음은 **ClientComponent.tsx**의 코드입니다. 흥미롭게도 이 컴포넌트의 코드는 전혀 변경할 필요가 없습니다. next/dynamic을 통해 렌더링 제어의 책임이 부모 컴포넌트로 넘어갔기 때문입니다.

```typescript
// ClientComponent.tsx (자식 컴포넌트)
'use client';

import { useSuspenseQuery } from '@tanstack/react-query';

// 임의의 데이터 fetch 함수
async function fetchData() {
  // 실제 네트워크 딜레이를 시뮬레이션
  await new Promise(resolve => setTimeout(resolve, 1000));
  // ... API 호출 로직 ...
  return { title: 'Fetched Data on Client!' };
}

export default function ClientComponent() {
  // 이 코드는 이제 ssr: false 덕분에 클라이언트에서만 실행되므로 안전합니다.
  const { data } = useSuspenseQuery({
    queryKey: ['data'],
    queryFn: fetchData
  });

  return <div>{data.title}</div>;
}
```


코드 예시를 통해 해결 방법이 얼마나 간단하고 명확한지 확인하셨을 것입니다. 이제 마지막으로 이 경험을 통해 얻을 수 있는 중요한 교훈을 정리해 보겠습니다.

6. 결론: App Router 렌더링 전략의 이해

useSuspenseQuery와 클라이언트 컴포넌트 조합 사용 시 발생한 서버 행 이슈는 단순한 버그가 아닙니다. 이는 Next.js App Router가 채택한 렌더링 모델에 대한 깊은 이해가 왜 중요한지를 보여주는 매우 좋은 사례이며, 의도적인 렌더링 경계 설계의 필요성을 역설합니다.

이 글을 통해 우리가 얻은 핵심 교훈은 다음과 같습니다.

* 핵심 교훈 1: 'use client'는 서버 렌더링을 배제하는 지시어가 아닙니다. 이는 서버에서 사전 렌더링 후 클라이언트에서 하이드레이션하는, 즉 SSR과 CSR이 결합된 App Router의 기본 모델을 의미합니다.
* 핵심 교훈 2: 만약 컴포넌트가 서버 환경에서는 실행되어서는 안 되는 클라이언트 전용 데이터 페칭 로직이나 API를 포함하고 있다면, next/dynamic과 ssr: false 옵션을 사용하는 것은 단순한 문제 해결이 아닌, 필수적인 아키텍처 결정입니다. 이를 통해 명확한 CSR 경계를 설정해야 합니다.

이제 여러분은 Next.js의 렌더링 전략을 더 효과적으로 활용할 준비가 되었습니다. 이 글에서 다룬 원리와 해결책을 바탕으로 유사한 문제를 예방하고, 더욱 견고하고 안정적인 애플리케이션을 구축하시기를 바랍니다.5:T18cd,
# 프론트엔드 개발, OOP와 FP의 완벽한 조화: 실무 적용 가이드

프론트엔드 개발 생태계는 빠르게 변화했습니다. 과거 UI를 클래스로 제어하던 시절을 지나, React Hooks와 Redux의 등장으로 함수형 프로그래밍(FP)의 개념이 깊숙이 자리 잡았습니다.

많은 개발자가 **"그래서 클래스를 써야 해, 함수를 써야 해?"**라는 질문을 던집니다. 하지만 모던 프론트엔드 아키텍처의 핵심은 양자택일이 아닌 **적재적소의 조화(Harmony)**에 있습니다.

이번 포스팅에서는 프론트엔드 실무에서 **객체 지향 프로그래밍(OOP)**과 **함수형 프로그래밍(FP)**을 어떻게 섞어 써야 가장 효율적인지, 구체적인 케이스와 코드를 통해 알아봅니다.

---

## 1. 객체 지향 프로그래밍 (OOP)
> **핵심 키워드:** 캡슐화(Encapsulation), 상태 유지, 응집도

OOP는 데이터(State)와 그 데이터를 조작하는 행위(Method)를 하나의 '객체'로 묶어서 관리합니다. 프론트엔드에서 OOP가 빛을 발하는 순간은 **"맥락(Context)을 유지해야 할 때"**입니다.

### 📌 Best Case: 외부 시스템 및 연결 관리 (Service Layer)
API 클라이언트, 소켓 연결, 복잡한 인증 로직처럼 **설정값이나 연결 상태를 계속 유지해야 하는 경우** 클래스가 유리합니다.

#### ❌ FP만 고집할 때의 문제점 (Prop Drilling)
모든 함수에 토큰이나 설정값을 인자로 계속 넘겨줘야 합니다.

```typescript
// 매번 token을 인자로 받아야 함 (불편함)
const fetchUser = (token: string, userId: string) => {
  return fetch(`/api/users/${userId}`, {
    headers: { Authorization: token }
  });
};
```

#### ✅ OOP를 활용한 해결책 (Encapsulation)
`ApiClient` 클래스 내부에 토큰과 Base URL을 **캡슐화**하면, 사용하는 쪽에서는 내부 구현을 신경 쓸 필요가 없습니다.

```typescript
class ApiClient {
  constructor(private token: string, private baseUrl: string) {}

  // 설정값(token)을 내부 상태로 관리하여 응집도를 높임
  private async request(path: string) {
    return fetch(`${this.baseUrl}${path}`, {
      headers: { Authorization: this.token }
    });
  }

  getUser(userId: string) {
    return this.request(`/users/${userId}`);
  }
}

// 사용: 사용하는 쪽 코드가 깔끔해짐
const api = new ApiClient('user-token-123', 'https://api.app.com');
api.getUser('user-1'); // 토큰을 넘길 필요 없음
```

---

## 2. 함수형 프로그래밍 (FP)
> **핵심 키워드:** 순수 함수(Pure Function), 불변성(Immutability), 파이프라인

FP는 부수 효과(Side-effect)를 없애고 입력이 같으면 출력도 같다는 것을 보장합니다. 프론트엔드에서 FP가 빛을 발하는 순간은 **"데이터를 가공하고 계산할 때"**입니다.

### 📌 Best Case: 비즈니스 로직 및 데이터 변환
서버에서 받은 데이터를 필터링하거나, 장바구니 합계를 계산하는 등의 로직은 순수 함수로 작성하는 것이 좋습니다.

#### ❌ OOP 스타일의 문제점 (강한 결합)
로직이 특정 객체의 상태(`this`)에 의존하면, 테스트하기 어렵고 다른 곳에서 재사용하기 힘듭니다.

```typescript
class ShoppingCart {
  private items: Product[] = [];
  
  // 상태와 로직이 섞여 있어 테스트가 번거로움
  calculateTotal() {
    return this.items.reduce((sum, item) => sum + item.price, 0);
  }
}
```

#### ✅ FP를 활용한 해결책 (Predictability)
데이터 구조와 로직을 분리합니다. `calculateTotal` 함수는 오직 입력받은 배열에만 의존하므로 예측 가능하고 테스트가 쉽습니다.

```typescript
// 순수 함수: Input -> Output이 명확함
const calculateTotal = (items: Product[]): number => {
  const total = items.reduce((sum, item) => sum + item.price, 0);
  // 배송비 계산 로직 등 확장에도 유연함
  return total > 30000 ? total : total + 3000;
};

// 사용: 어디서든 재사용 가능
const finalPrice = calculateTotal(cartItems);
```

---

## 3. 결론: 하이브리드 아키텍처 (Harmony)

실제 프로덕션 레벨의 프론트엔드 코드는 이 두 가지 패러다임을 혼합하여 사용합니다. React 컴포넌트는 이 둘을 이어주는 **접착제(Glue)** 역할을 수행합니다.

### 💡 실무 적용 패턴 예시

1.  **OOP:** 복잡한 API 통신과 설정은 `Class`로 관리합니다.
2.  **FP:** 데이터를 화면에 보여주기 위한 가공은 `Pure Function`을 사용합니다.
3.  **React:** 이 둘을 조합하여 UI를 렌더링합니다.

```tsx
// 1. [OOP] Service Layer 인스턴스 생성
const authService = new AuthService(config);

const UserList = () => {
  const [users, setUsers] = useState([]);

  useEffect(() => {
    // [OOP] 메서드 호출: 복잡한 인증 로직은 숨겨져 있음
    authService.getUsers().then(setUsers);
  }, []);

  // 2. [FP] 순수 함수 사용: 데이터 가공 로직 분리
  // sortUsersByName은 외부 파일에 정의된 순수 함수라고 가정
  const sortedUsers = useMemo(() => sortUsersByName(users), [users]);

  return (
    <ul>
      {/* 3. [FP] 선언적 렌더링 */}
      {sortedUsers.map(user => (
        <li key={user.id}>{user.name}</li>
      ))}
    </ul>
  );
};
```

### 요약: 언제 무엇을 써야 할까?

| 구분 | 역할 | 추천 패러다임 | 이유 |
| :--- | :--- | :--- | :--- |
| **API / Service** | 데이터 페칭, 소켓, 인증 | **OOP** | 설정값과 연결 상태를 **캡슐화**하기 위해 |
| **Business Logic** | 계산, 포맷팅, 필터링 | **FP** | **테스트 용이성**과 예측 가능성을 위해 |
| **Store** | 전역 상태 변경 (Redux 등) | **FP** | **불변성**을 통한 상태 변경 추적을 위해 |
| **UI Component** | 화면 렌더링 | **Hybrid** | 라이프사이클(OOP) + 렌더링 로직(FP) |

프론트엔드 개발자로서 한 가지 패러다임에 갇히기보다, 각 패러다임이 가진 장점을 이해하고 상황에 맞게 골라 쓰는 유연함이 필요합니다. 

**"상태 관리는 OOP처럼, 데이터 처리는 FP처럼."** 이 원칙을 기억하면 더 견고한 애플리케이션을 설계할 수 있을 것입니다.
6:T13dd,
# 무조건적인 가상화(Virtualization) 도입, 과연 정답일까? (feat. content-visibility)

프론트엔드 개발자라면 긴 리스트를 다룰 때 습관적으로 **"가상화(Virtualization)를 도입해야겠다"**고 생각합니다. `react-window`나 `tanstack-virtual` 같은 라이브러리를 설치하는 것이 일종의 'Best Practice'처럼 여겨지죠.

하지만 10년 차 프론트엔드 개발자로서 수많은 프로젝트를 거치며 깨달은 점은, **가상화는 공짜 점심이 아니라는 사실**입니다. 가상화는 성능을 얻는 대신 **UX(사용자 경험)**를 비용으로 지불합니다.

오늘은 리스트 렌더링 성능 최적화의 본질적인 원리와, 가상화가 가진 UX 결함, 그리고 이를 대체할 수 있는 모던 CSS 전략(`content-visibility`)에 대해 이야기해보려 합니다.

---

## 1. 우리는 왜 가상화를 하는가? (본질적인 병목)

데이터가 수천, 수만 개로 늘어날 때 브라우저가 느려지는 진짜 이유는 무엇일까요? 단순히 "데이터가 많아서"가 아닙니다.

### DOM 개수의 비대화와 선형적 성능 저하
가장 큰 문제는 DOM 노드의 개수입니다. 리스트 아이템이 1만 개이고, 각 아이템이 10개의 태그를 가진다면 브라우저는 **10만 개의 DOM 노드**를 메모리에 올리고 관리해야 합니다.

문제는 사용자가 스크롤을 내려 페이지가 쌓일수록 성능 저하가 **선형적(Linear)**으로 발생한다는 점입니다.
* **Recalculate Style 비용 증가:** 버튼 하나를 클릭해 상태가 바뀌어도, 브라우저는 거대해진 DOM 트리를 순회하며 스타일 계산을 다시 해야 합니다.
* **메모리 누수:** 화면 밖으로 지나간 수천 개의 이미지와 컴포넌트들이 메모리(RAM/VRAM)를 계속 점유합니다.

가상화(Virtualization)는 이 문제를 해결하기 위해 **"보이는 영역(Viewport)만 렌더링하고, 벗어난 영역은 DOM에서 제거"**하는 기술입니다. 덕분에 데이터가 100만 개여도 DOM 노드는 항상 20개 내외로 유지됩니다.

---

## 2. 오해: "스크롤하면 리페인트(Repaint)가 발생해서 느리다?"

많은 개발자가 *"DOM이 많으면 스크롤할 때마다 리페인트가 발생해서 느리다"*고 오해합니다. 결론부터 말하면 **최신 브라우저에서 최적화된 네이티브 스크롤은 리페인트를 유발하지 않습니다.**

### 브라우저의 스크롤 동작 원리 (Pixel Pipeline)
1.  **Composite Only:** 브라우저는 스크롤 가능한 영역을 별도의 **레이어(Layer)**로 승격(Promote)시킵니다.
2.  **GPU 가속:** 이미 그려진(Paint 완료된) 비트맵 텍스처를 GPU가 좌표만 이동시킵니다.
3.  **결과:** Layout과 Paint 단계를 건너뛰고 **Composite** 단계만 수행하므로 매우 부드럽습니다.

### 그렇다면 가상화 없는 1만 개 리스트는 왜 버벅거릴까?
리페인트 때문이 아니라, 다른 연산 비용 때문입니다.
1.  **Hit Testing 과부하:** 스크롤 중 마우스 커서 아래에 어떤 요소가 있는지(Hover, Event 등) 계산해야 하는데, DOM이 1만 개면 이 탐색 비용이 16ms(60fps)를 초과합니다.
2.  **GPU 대역폭 한계:** 1만 개 분량의 거대한 텍스처를 타일링(Tiling)하고 GPU 메모리로 전송하는 과정에서 병목이 발생합니다.
3.  **GC(가비지 컬렉션):** 수많은 DOM 노드 참조로 인해 GC 수행 시간이 길어져 스크롤이 턱턱 걸리게 됩니다.

아이러니하게도, **가상화를 적용하면 스크롤할 때마다 필연적으로 리페인트가 발생**합니다. JS가 DOM을 계속 갈아 끼우기 때문이죠. 하지만 "전체 DOM을 유지하는 비용"보다 "작은 영역을 계속 다시 그리는 비용"이 훨씬 싸기 때문에 가상화를 쓰는 것입니다.

---

## 3. 가상화의 치명적인 단점 (UX Trade-offs)

성능을 위해 가상화를 도입하면 다음과 같은 UX 손해를 감수해야 합니다.

1.  **Ctrl + F (검색) 불가:** DOM에 요소가 없으니 브라우저 기본 찾기 기능으로 내용을 찾을 수 없습니다.
2.  **스크롤 이질감:** 네이티브 스크롤의 관성, 바운스 등을 JS로 흉내 내야 하므로 미묘하게 어색합니다.
3.  **스크롤바 널뛰기:** 동적 높이(Dynamic Height) 아이템일 경우, 스크롤바가 떨리거나 위치가 튀는 현상이 발생합니다.
4.  **빈 화면(White Space):** 스크롤 속도가 렌더링 속도보다 빠르면 하얀 빈 공간이 보입니다.

---

## 4. 현실적인 대안: CSS `content-visibility`

"데이터가 100~200개 정도인데 가상화를 써야 할까?"
이런 고민이 든다면, 가상화는 오버엔지니어링일 확률이 높습니다. 이때 사용할 수 있는 강력한 대안이 CSS의 **`content-visibility: auto`** 입니다.

```css
.list-item {
  content-visibility: auto;
  contain-intrinsic-size: 100px; /* 아이템의 예상 높이 */
}

```
7:T1f43,
# [Architecture] NPM 패키지 분리 환경에서 싱글톤(Singleton) 유지하기: globalThis와 Symbol.for의 활용

최근 사내 패키지 배포 구조를 개선하면서 마주친 문제와 그 해결 과정을 공유합니다.

여러 프로젝트에서 공통으로 사용하는 패키지들을 npm 저장소(Nexus 등)에 배포하여 관리하고 있는데, 배포 편의성을 위해 의존성 패키지를 번들(Bundle)에 포함시키는 과정에서 **싱글톤(Singleton) 객체가 유지되지 않는 이슈**가 발생했습니다.

이 글에서는 물리적으로 분리된 번들 환경에서 어떻게 안전하게 싱글톤 인스턴스를 공유했는지, 그 과정에서 **`globalThis`**와 **`Symbol.for`**를 어떻게 활용했는지 다룹니다.

## 1. 문제 상황 (The Problem)

### 아키텍처 구조
현재 우리 팀은 다음과 같은 3가지 패키지를 운용하고 있습니다.

* **Framework**: 핵심 로직과 싱글톤 객체(Store, Manager 등)를 제공
* **Editor**: `Framework`를 의존하여 사용하는 편집 도구
* **Converter**: `Framework`를 의존하여 사용하는 변환 도구

배포 및 설치 편의성을 위해 `Editor`와 `Converter`를 배포할 때, 이들이 의존하는 `Framework` 코드를 각각의 번들에 포함(Bundled)시켜 배포했습니다.

### 발생한 이슈
호스트 애플리케이션에서 `Editor`와 `Converter`를 동시에 설치해서 사용할 때 문제가 발생했습니다.

1.  `Editor`가 로드되면서 내부의 `Framework`가 초기화됨 (싱글톤 A 생성)
2.  `Converter`가 로드되면서 내부의 `Framework`가 초기화됨 (싱글톤 B 생성)
3.  **결과:** 두 패키지가 **서로 다른 싱글톤 인스턴스**를 바라보게 되어 상태 공유가 불가능해짐.

## 2. 원인 분석

일반적인 ES Module 시스템에서 싱글톤은 **모듈 스코프(Module Scope)** 내의 클로저를 통해 유지됩니다.

하지만 번들링을 하게 되면 각 번들 파일(`editor.bundle.js`, `converter.bundle.js`)마다 `Framework`의 코드가 복제되어 들어갑니다. 자바스크립트 런타임 입장에서 이 두 코드는 **서로 다른 물리적 모듈**로 취급되므로, 각각 별도의 실행 컨텍스트와 메모리 공간을 갖게 됩니다.

따라서 모듈 시스템의 스코프를 넘어선 **전역 공간(Global Scope)**을 통한 상태 공유가 필요했습니다.

## 3. 해결 전략: Global Scope 활용

### 1차 접근: 전역 객체(globalThis) 사용
브라우저와 Node.js 환경 모두를 아우를 수 있는 표준인 `globalThis`에 인스턴스를 저장하기로 했습니다.

```typescript
// 단순히 문자열 키를 사용한다면?
globalThis['MY_FRAMEWORK_INSTANCE'] = new Framework();
```

하지만 단순히 문자열 키(`string key`)를 사용하는 것은 다음과 같은 위험이 있습니다.
* **이름 충돌:** 다른 라이브러리나 레거시 코드에서 우연히 같은 이름을 사용할 경우 덮어씌워질 위험이 있음.
* **전역 오염:** `Object.keys(window)` 등으로 조회했을 때 노출되어, 의도치 않은 접근이나 수정이 발생할 수 있음.

### 2차 접근: Symbol.for() 활용 (최종 솔루션)
이 문제를 해결하기 위해 **`Symbol.for()`**를 사용했습니다.

* **Namespace 격리:** Symbol은 일반 문자열 키와 다른 레이어에 저장되므로, 일반적인 전역 변수 접근으로 오염될 일이 없습니다.
* **Cross-Realm 공유:** `Symbol()`은 호출할 때마다 매번 다른 값을 만들지만, `Symbol.for('key')`는 **전역 심볼 레지스트리**를 통해 키가 같으면 동일한 심볼 객체를 반환합니다. 즉, **번들이 달라도 같은 심볼을 가리킬 수 있습니다.**

## 4. 구현 코드 (Implementation)

기존의 싱글톤 레지스트리 패턴에 `globalThis`와 `Symbol.for`를 적용한 구현입니다.

### SingletonRegistry.ts

```typescript
// 1. 전역에서 유일성을 보장하기 위한 Symbol 키 생성
// 충돌 방지를 위해 회사 도메인 등을 포함한 긴 네이밍 권장
const CONSTRUCTORS_KEY = Symbol.for('my-org.framework.registry.constructors');
const SINGLETONS_KEY = Symbol.for('my-org.framework.registry.singletons');

// 2. 전역 객체 타입 정의 (TypeScript)
type GlobalWithRegistry = typeof globalThis & {
  [CONSTRUCTORS_KEY]?: Map<string, new (...args: any[]) => any>;
  [SINGLETONS_KEY]?: Map<string, any>;
};

// 3. 전역 맵 접근 헬퍼 (초기화 로직 포함)
function getGlobalSingletons(): Map<string, any> {
  const g = globalThis as GlobalWithRegistry;
  if (!g[SINGLETONS_KEY]) {
    g[SINGLETONS_KEY] = new Map();
  }
  return g[SINGLETONS_KEY]!;
}

// ... 생성자 맵 접근 함수도 동일한 방식 ...

export namespace SingletonRegistry {
  export const register = (name: string, constructor: new (...args: any[]) => any) => {
    // 로컬 변수가 아닌 전역 심볼 맵에 저장
    getGlobalConstructors().set(name, constructor);
  };

  export const resolve = (name: string) => {
    const singletons = getGlobalSingletons();
    
    // 이미 생성된 인스턴스가 전역 맵에 있는지 확인
    if (!singletons.has(name)) {
      const constructors = getGlobalConstructors();
      const constructor = constructors.get(name);
      
      if (!constructor) {
        throw new Error(`Singleton ${name} is not registered`);
      }
      
      // 인스턴스 생성 후 전역 맵에 저장 -> 다른 번들에서도 이 인스턴스를 보게 됨 
      singletons.set(name, new constructor());
    }

    return singletons.get(name);
  };
}
```

이렇게 구현하면 `Editor` 번들에서 먼저 `resolve`를 호출해 인스턴스를 만들면, 나중에 로드된 `Converter` 번들에서도 `globalThis`의 심볼 키를 통해 **동일한 인스턴스**를 찾아 반환하게 됩니다.

## 5. 주의사항 및 한계 (Trade-offs)

이 방식은 유용한 "탈출구(Escape Hatch)"이지만, 몇 가지 주의할 점이 있습니다.

### 1) `instanceof` 체크 불가
서로 다른 번들에서 로드된 클래스는 내용은 같아도 자바스크립트 엔진상 **다른 생성자 함수**입니다. 따라서 `resolve()`로 가져온 객체에 대해 `instanceof` 검사를 하면 `false`가 나올 수 있습니다.
* **해결:** 타입 체크가 필요하다면 `instanceof` 대신 **Duck Typing**이나 공통 **Interface**를 사용해야 합니다.

### 2) 버전 관리 (Version Mismatch)
만약 `Editor`는 Framework v1.0을, `Converter`는 Framework v2.0을 번들링하고 있다면 런타임 에러가 발생할 수 있습니다. (v1 인스턴스가 전역에 있는데 v2 메서드를 호출하는 경우 등)
* **해결:** 모든 패키지가 동일한 버전의 Framework를 사용하도록 CI 단계에서 엄격하게 관리하거나, 심볼 키에 버전을 명시(`Symbol.for('...v1')`)하여 격리해야 합니다.

### 3) 테스트 격리
단위 테스트(Jest/Vitest) 실행 시 `globalThis`가 오염되어 테스트 간 간섭이 발생할 수 있습니다. `afterEach` 등에서 전역 심볼 맵을 초기화해주는 작업이 필요합니다.

## 6. 결론

NPM 패키지 배포 시 번들링 전략에 따라 싱글톤 패턴이 깨지는 문제는 흔히 발생할 수 있습니다. 가장 정석적인 방법은 `peerDependencies`를 사용하여 호스트가 단일 버전을 설치하게 하는 것이지만, 배포 및 사용 편의성을 위해 번들링이 필수적인 상황이라면 **`globalThis`와 `Symbol.for`를 활용한 전역 레지스트리 패턴**이 훌륭한 해결책이 될 수 있습니다.

이 패턴은 React, Styled-components 등 유명 라이브러리들에서도 런타임 환경의 제약을 극복하기 위해 내부적으로 사용하는 검증된 방식입니다. 다만, 사용 시 발생할 수 있는 사이드 이펙트(버전, 타입 체크)를 충분히 인지하고 적용해야 합니다.
0:{"buildId":"R3pqlmRXWe1l02D11KmII","rsc":["$","$1","c",{"children":[["$","$L2",null,{"posts":[{"title":"Datadog vs Sentry: 우리 팀에 맞는 모니터링 툴은 무엇일까?","summary":"Datadog과 Sentry의 특징과 장단점을 비교하여 팀의 상황에 맞는 최적의 모니터링 도구를 선택하는 방법을 알아봅니다.","tags":["Datadog","Sentry","Monitoring","APM","RUM"],"date":"2025-12-21","id":"sentry-vs-datadog","content":"$3"},{"title":"Next.js App Router: useSuspenseQuery 서버 행(Hanging) 이슈 해결","date":"2025-12-20","tags":["Next.js","React Query","App Router"],"summary":"App Router에서 useSuspenseQuery 사용 시 발생하는 서버 행 현상의 원인을 파헤치고 next/dynamic을 통한 해결책을 제시합니다.","id":"app-router-useSuspenseQuery","content":"$4"},{"title":"프론트엔드 OOP와 FP 조화: 실무 적용 완벽 가이드","summary":"프론트엔드 개발에서 객체 지향 프로그래밍(OOP)과 함수형 프로그래밍(FP)을 조화롭게 사용하여 효율적인 아키텍처를 구축하는 방법을 알아봅니다.","tags":["frontend","OOP","FP","architecture","javascript"],"date":"2025-12-20","id":"frontend-oop-fp","content":"$5"},{"title":"가상화(Virtualization) 도입, 과연 정답일까? (feat. content-visibility)","summary":"가상화의 성능상 이점과 UX상의 단점을 살펴보고, content-visibility를 이용한 대안을 제시합니다.","tags":["virtualization","performance","css","content-visibility","frontend"],"date":"2025-12-20","id":"scroll-virtualization","content":"$6"},{"title":"NPM 패키지 분리 환경에서 싱글톤(Singleton) 유지하기: globalThis와 Symbol.for의 활용","summary":"물리적으로 분리된 번들 환경에서 globalThis와 Symbol.for를 활용하여 싱글톤 인스턴스를 안전하게 공유하는 방법을 설명합니다.","tags":["NPM","Singleton","globalThis","Symbol.for","JavaScript"],"date":"2025-12-20","id":"singleton-in-package","content":"$7"}]}],["$L8"],"$L9"]}],"loading":null,"isPartial":false}
8:["$","script","script-0",{"src":"/_next/static/chunks/c8696c5ee1a86c19.js","async":true}]
9:["$","$La",null,{"children":["$","$b",null,{"name":"Next.MetadataOutlet","children":"$@c"}]}]
c:null
