1:"$Sreact.fragment"
2:I[70451,["/_next/static/chunks/c6311bd1204a06f2.js","/_next/static/chunks/5ec360913fe0c25f.js","/_next/static/chunks/c44bdab66bebb21f.js"],""]
3:I[74553,["/_next/static/chunks/c6311bd1204a06f2.js","/_next/static/chunks/5ec360913fe0c25f.js","/_next/static/chunks/c44bdab66bebb21f.js"],"PostViewer"]
8:I[65126,["/_next/static/chunks/c6311bd1204a06f2.js","/_next/static/chunks/5ec360913fe0c25f.js","/_next/static/chunks/c44bdab66bebb21f.js"],"default"]
9:I[97990,["/_next/static/chunks/28ff6a04602448ba.js","/_next/static/chunks/64c697a3cb51cd07.js"],"OutletBoundary"]
a:"$Sreact.suspense"
4:T13dd,
# 무조건적인 가상화(Virtualization) 도입, 과연 정답일까? (feat. content-visibility)

프론트엔드 개발자라면 긴 리스트를 다룰 때 습관적으로 **"가상화(Virtualization)를 도입해야겠다"**고 생각합니다. `react-window`나 `tanstack-virtual` 같은 라이브러리를 설치하는 것이 일종의 'Best Practice'처럼 여겨지죠.

하지만 10년 차 프론트엔드 개발자로서 수많은 프로젝트를 거치며 깨달은 점은, **가상화는 공짜 점심이 아니라는 사실**입니다. 가상화는 성능을 얻는 대신 **UX(사용자 경험)**를 비용으로 지불합니다.

오늘은 리스트 렌더링 성능 최적화의 본질적인 원리와, 가상화가 가진 UX 결함, 그리고 이를 대체할 수 있는 모던 CSS 전략(`content-visibility`)에 대해 이야기해보려 합니다.

---

## 1. 우리는 왜 가상화를 하는가? (본질적인 병목)

데이터가 수천, 수만 개로 늘어날 때 브라우저가 느려지는 진짜 이유는 무엇일까요? 단순히 "데이터가 많아서"가 아닙니다.

### DOM 개수의 비대화와 선형적 성능 저하
가장 큰 문제는 DOM 노드의 개수입니다. 리스트 아이템이 1만 개이고, 각 아이템이 10개의 태그를 가진다면 브라우저는 **10만 개의 DOM 노드**를 메모리에 올리고 관리해야 합니다.

문제는 사용자가 스크롤을 내려 페이지가 쌓일수록 성능 저하가 **선형적(Linear)**으로 발생한다는 점입니다.
* **Recalculate Style 비용 증가:** 버튼 하나를 클릭해 상태가 바뀌어도, 브라우저는 거대해진 DOM 트리를 순회하며 스타일 계산을 다시 해야 합니다.
* **메모리 누수:** 화면 밖으로 지나간 수천 개의 이미지와 컴포넌트들이 메모리(RAM/VRAM)를 계속 점유합니다.

가상화(Virtualization)는 이 문제를 해결하기 위해 **"보이는 영역(Viewport)만 렌더링하고, 벗어난 영역은 DOM에서 제거"**하는 기술입니다. 덕분에 데이터가 100만 개여도 DOM 노드는 항상 20개 내외로 유지됩니다.

---

## 2. 오해: "스크롤하면 리페인트(Repaint)가 발생해서 느리다?"

많은 개발자가 *"DOM이 많으면 스크롤할 때마다 리페인트가 발생해서 느리다"*고 오해합니다. 결론부터 말하면 **최신 브라우저에서 최적화된 네이티브 스크롤은 리페인트를 유발하지 않습니다.**

### 브라우저의 스크롤 동작 원리 (Pixel Pipeline)
1.  **Composite Only:** 브라우저는 스크롤 가능한 영역을 별도의 **레이어(Layer)**로 승격(Promote)시킵니다.
2.  **GPU 가속:** 이미 그려진(Paint 완료된) 비트맵 텍스처를 GPU가 좌표만 이동시킵니다.
3.  **결과:** Layout과 Paint 단계를 건너뛰고 **Composite** 단계만 수행하므로 매우 부드럽습니다.

### 그렇다면 가상화 없는 1만 개 리스트는 왜 버벅거릴까?
리페인트 때문이 아니라, 다른 연산 비용 때문입니다.
1.  **Hit Testing 과부하:** 스크롤 중 마우스 커서 아래에 어떤 요소가 있는지(Hover, Event 등) 계산해야 하는데, DOM이 1만 개면 이 탐색 비용이 16ms(60fps)를 초과합니다.
2.  **GPU 대역폭 한계:** 1만 개 분량의 거대한 텍스처를 타일링(Tiling)하고 GPU 메모리로 전송하는 과정에서 병목이 발생합니다.
3.  **GC(가비지 컬렉션):** 수많은 DOM 노드 참조로 인해 GC 수행 시간이 길어져 스크롤이 턱턱 걸리게 됩니다.

아이러니하게도, **가상화를 적용하면 스크롤할 때마다 필연적으로 리페인트가 발생**합니다. JS가 DOM을 계속 갈아 끼우기 때문이죠. 하지만 "전체 DOM을 유지하는 비용"보다 "작은 영역을 계속 다시 그리는 비용"이 훨씬 싸기 때문에 가상화를 쓰는 것입니다.

---

## 3. 가상화의 치명적인 단점 (UX Trade-offs)

성능을 위해 가상화를 도입하면 다음과 같은 UX 손해를 감수해야 합니다.

1.  **Ctrl + F (검색) 불가:** DOM에 요소가 없으니 브라우저 기본 찾기 기능으로 내용을 찾을 수 없습니다.
2.  **스크롤 이질감:** 네이티브 스크롤의 관성, 바운스 등을 JS로 흉내 내야 하므로 미묘하게 어색합니다.
3.  **스크롤바 널뛰기:** 동적 높이(Dynamic Height) 아이템일 경우, 스크롤바가 떨리거나 위치가 튀는 현상이 발생합니다.
4.  **빈 화면(White Space):** 스크롤 속도가 렌더링 속도보다 빠르면 하얀 빈 공간이 보입니다.

---

## 4. 현실적인 대안: CSS `content-visibility`

"데이터가 100~200개 정도인데 가상화를 써야 할까?"
이런 고민이 든다면, 가상화는 오버엔지니어링일 확률이 높습니다. 이때 사용할 수 있는 강력한 대안이 CSS의 **`content-visibility: auto`** 입니다.

```css
.list-item {
  content-visibility: auto;
  contain-intrinsic-size: 100px; /* 아이템의 예상 높이 */
}

```
0:{"buildId":"yx8YUX__cxlbsvUkAHFS7","rsc":["$","$1","c",{"children":[["$","div",null,{"className":"mx-auto p-8","children":[["$","script",null,{"type":"application/ld+json","dangerouslySetInnerHTML":{"__html":"{\"@context\":\"https://schema.org\",\"@type\":\"BlogPosting\",\"headline\":\"가상화(Virtualization) 도입, 과연 정답일까? (feat. content-visibility)\",\"datePublished\":\"2025-12-20\",\"dateModified\":\"2025-12-20\",\"description\":\"가상화의 성능상 이점과 UX상의 단점을 살펴보고, content-visibility를 이용한 대안을 제시합니다.\",\"author\":{\"@type\":\"Person\",\"name\":\"Dev-Holic\"},\"url\":\"https://dev-holic.github.io/blog/scroll-virtualization\",\"keywords\":[\"virtualization\",\"performance\",\"css\",\"content-visibility\",\"frontend\"]}"}}],["$","$L2",null,{"href":"/","className":"mb-4 inline-block text-blue-500 hover:underline","children":"← Back to List"}],["$","header",null,{"className":"mb-8","children":[["$","h1",null,{"className":"mb-4 text-4xl font-bold text-gray-900 dark:text-gray-100","children":"가상화(Virtualization) 도입, 과연 정답일까? (feat. content-visibility)"}],["$","div",null,{"className":"text-gray-500 dark:text-gray-400","children":["2025-12-20",["$","span",null,{"className":"ml-2","children":["• ","#virtualization #performance #css #content-visibility #frontend"]}]]}]]}],["$","$L3",null,{"content":"$4","postId":"scroll-virtualization"}],"$L5"]}],["$L6"],"$L7"]}],"loading":null,"isPartial":false}
5:["$","$L8",null,{}]
6:["$","script","script-0",{"src":"/_next/static/chunks/c44bdab66bebb21f.js","async":true}]
7:["$","$L9",null,{"children":["$","$a",null,{"name":"Next.MetadataOutlet","children":"$@b"}]}]
b:null
