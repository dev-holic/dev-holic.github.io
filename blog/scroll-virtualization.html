<!DOCTYPE html><!--yx8YUX__cxlbsvUkAHFS7--><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="/_next/static/chunks/abdb394ac1358659.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/8b92303ff08c461e.js"/><script src="/_next/static/chunks/55aefddb5fcea8c7.js" async=""></script><script src="/_next/static/chunks/22253ee93289876a.js" async=""></script><script src="/_next/static/chunks/d87cd5742aeed2ef.js" async=""></script><script src="/_next/static/chunks/turbopack-2d45e4821fd8bdec.js" async=""></script><script src="/_next/static/chunks/28ff6a04602448ba.js" async=""></script><script src="/_next/static/chunks/64c697a3cb51cd07.js" async=""></script><script src="/_next/static/chunks/c6311bd1204a06f2.js" async=""></script><script src="/_next/static/chunks/5ec360913fe0c25f.js" async=""></script><script src="/_next/static/chunks/c44bdab66bebb21f.js" async=""></script><link rel="icon" type="image/svg+xml" href="/vite.svg"/><meta name="google-site-verification" content="sXxEHSK4sTx3BrDha-kpJpFaszf3wxeSU5ojx8sqq1A"/><title>가상화(Virtualization) 도입, 과연 정답일까? (feat. content-visibility) | Dev-Holic Blog</title><meta name="description" content="가상화의 성능상 이점과 UX상의 단점을 살펴보고, content-visibility를 이용한 대안을 제시합니다."/><meta property="og:title" content="Dev-Holic Blog"/><meta property="og:description" content="Tech, Development, and more"/><meta property="og:url" content="https://dev-holic.github.io"/><meta property="og:site_name" content="Dev-Holic Blog"/><meta property="og:locale" content="ko_KR"/><meta property="og:image:alt" content="Blog Post Image"/><meta property="og:image:type" content="image/png"/><meta property="og:image" content="https://dev-holic.github.io/blog/scroll-virtualization/opengraph-image?a07550892c625387"/><meta property="og:image:width" content="1200"/><meta property="og:image:height" content="630"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="Dev-Holic Blog"/><meta name="twitter:description" content="Tech, Development, and more"/><meta name="twitter:image:alt" content="Blog Post Image"/><meta name="twitter:image:type" content="image/png"/><meta name="twitter:image" content="https://dev-holic.github.io/blog/scroll-virtualization/opengraph-image?a07550892c625387"/><meta name="twitter:image:width" content="1200"/><meta name="twitter:image:height" content="630"/><script src="/_next/static/chunks/a6dad97d9634a72d.js" noModule=""></script></head><body class="bg-white text-gray-900 dark:bg-gray-900 dark:text-gray-100"><div hidden=""><!--$--><!--/$--></div><script type="application/ld+json">{"@context":"https://schema.org","@type":"WebSite","name":"Dev-Holic Blog","url":"https://dev-holic.github.io"}</script><div class="relative mx-auto flex h-screen w-full max-w-7xl flex-col overflow-hidden md:flex-row"><main class="h-full w-full flex-1 overflow-y-auto"><div class="mx-auto p-8"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","headline":"가상화(Virtualization) 도입, 과연 정답일까? (feat. content-visibility)","datePublished":"2025-12-20","dateModified":"2025-12-20","description":"가상화의 성능상 이점과 UX상의 단점을 살펴보고, content-visibility를 이용한 대안을 제시합니다.","author":{"@type":"Person","name":"Dev-Holic"},"url":"https://dev-holic.github.io/blog/scroll-virtualization","keywords":["virtualization","performance","css","content-visibility","frontend"]}</script><a class="mb-4 inline-block text-blue-500 hover:underline" href="/">← Back to List</a><header class="mb-8"><h1 class="mb-4 text-4xl font-bold text-gray-900 dark:text-gray-100">가상화(Virtualization) 도입, 과연 정답일까? (feat. content-visibility)</h1><div class="text-gray-500 dark:text-gray-400">2025-12-20<span class="ml-2">• <!-- -->#virtualization #performance #css #content-visibility #frontend</span></div></header><div class="prose prose-lg dark:prose-invert max-w-none"><h1>무조건적인 가상화(Virtualization) 도입, 과연 정답일까? (feat. content-visibility)</h1>
<p>프론트엔드 개발자라면 긴 리스트를 다룰 때 습관적으로 **&quot;가상화(Virtualization)를 도입해야겠다&quot;**고 생각합니다. <code>react-window</code>나 <code>tanstack-virtual</code> 같은 라이브러리를 설치하는 것이 일종의 &#x27;Best Practice&#x27;처럼 여겨지죠.</p>
<p>하지만 10년 차 프론트엔드 개발자로서 수많은 프로젝트를 거치며 깨달은 점은, <strong>가상화는 공짜 점심이 아니라는 사실</strong>입니다. 가상화는 성능을 얻는 대신 **UX(사용자 경험)**를 비용으로 지불합니다.</p>
<p>오늘은 리스트 렌더링 성능 최적화의 본질적인 원리와, 가상화가 가진 UX 결함, 그리고 이를 대체할 수 있는 모던 CSS 전략(<code>content-visibility</code>)에 대해 이야기해보려 합니다.</p>
<hr/>
<h2>1. 우리는 왜 가상화를 하는가? (본질적인 병목)</h2>
<p>데이터가 수천, 수만 개로 늘어날 때 브라우저가 느려지는 진짜 이유는 무엇일까요? 단순히 &quot;데이터가 많아서&quot;가 아닙니다.</p>
<h3>DOM 개수의 비대화와 선형적 성능 저하</h3>
<p>가장 큰 문제는 DOM 노드의 개수입니다. 리스트 아이템이 1만 개이고, 각 아이템이 10개의 태그를 가진다면 브라우저는 <strong>10만 개의 DOM 노드</strong>를 메모리에 올리고 관리해야 합니다.</p>
<p>문제는 사용자가 스크롤을 내려 페이지가 쌓일수록 성능 저하가 **선형적(Linear)**으로 발생한다는 점입니다.</p>
<ul>
<li><strong>Recalculate Style 비용 증가:</strong> 버튼 하나를 클릭해 상태가 바뀌어도, 브라우저는 거대해진 DOM 트리를 순회하며 스타일 계산을 다시 해야 합니다.</li>
<li><strong>메모리 누수:</strong> 화면 밖으로 지나간 수천 개의 이미지와 컴포넌트들이 메모리(RAM/VRAM)를 계속 점유합니다.</li>
</ul>
<p>가상화(Virtualization)는 이 문제를 해결하기 위해 **&quot;보이는 영역(Viewport)만 렌더링하고, 벗어난 영역은 DOM에서 제거&quot;**하는 기술입니다. 덕분에 데이터가 100만 개여도 DOM 노드는 항상 20개 내외로 유지됩니다.</p>
<hr/>
<h2>2. 오해: &quot;스크롤하면 리페인트(Repaint)가 발생해서 느리다?&quot;</h2>
<p>많은 개발자가 *&quot;DOM이 많으면 스크롤할 때마다 리페인트가 발생해서 느리다&quot;*고 오해합니다. 결론부터 말하면 <strong>최신 브라우저에서 최적화된 네이티브 스크롤은 리페인트를 유발하지 않습니다.</strong></p>
<h3>브라우저의 스크롤 동작 원리 (Pixel Pipeline)</h3>
<ol>
<li><strong>Composite Only:</strong> 브라우저는 스크롤 가능한 영역을 별도의 **레이어(Layer)**로 승격(Promote)시킵니다.</li>
<li><strong>GPU 가속:</strong> 이미 그려진(Paint 완료된) 비트맵 텍스처를 GPU가 좌표만 이동시킵니다.</li>
<li><strong>결과:</strong> Layout과 Paint 단계를 건너뛰고 <strong>Composite</strong> 단계만 수행하므로 매우 부드럽습니다.</li>
</ol>
<h3>그렇다면 가상화 없는 1만 개 리스트는 왜 버벅거릴까?</h3>
<p>리페인트 때문이 아니라, 다른 연산 비용 때문입니다.</p>
<ol>
<li><strong>Hit Testing 과부하:</strong> 스크롤 중 마우스 커서 아래에 어떤 요소가 있는지(Hover, Event 등) 계산해야 하는데, DOM이 1만 개면 이 탐색 비용이 16ms(60fps)를 초과합니다.</li>
<li><strong>GPU 대역폭 한계:</strong> 1만 개 분량의 거대한 텍스처를 타일링(Tiling)하고 GPU 메모리로 전송하는 과정에서 병목이 발생합니다.</li>
<li><strong>GC(가비지 컬렉션):</strong> 수많은 DOM 노드 참조로 인해 GC 수행 시간이 길어져 스크롤이 턱턱 걸리게 됩니다.</li>
</ol>
<p>아이러니하게도, <strong>가상화를 적용하면 스크롤할 때마다 필연적으로 리페인트가 발생</strong>합니다. JS가 DOM을 계속 갈아 끼우기 때문이죠. 하지만 &quot;전체 DOM을 유지하는 비용&quot;보다 &quot;작은 영역을 계속 다시 그리는 비용&quot;이 훨씬 싸기 때문에 가상화를 쓰는 것입니다.</p>
<hr/>
<h2>3. 가상화의 치명적인 단점 (UX Trade-offs)</h2>
<p>성능을 위해 가상화를 도입하면 다음과 같은 UX 손해를 감수해야 합니다.</p>
<ol>
<li><strong>Ctrl + F (검색) 불가:</strong> DOM에 요소가 없으니 브라우저 기본 찾기 기능으로 내용을 찾을 수 없습니다.</li>
<li><strong>스크롤 이질감:</strong> 네이티브 스크롤의 관성, 바운스 등을 JS로 흉내 내야 하므로 미묘하게 어색합니다.</li>
<li><strong>스크롤바 널뛰기:</strong> 동적 높이(Dynamic Height) 아이템일 경우, 스크롤바가 떨리거나 위치가 튀는 현상이 발생합니다.</li>
<li><strong>빈 화면(White Space):</strong> 스크롤 속도가 렌더링 속도보다 빠르면 하얀 빈 공간이 보입니다.</li>
</ol>
<hr/>
<h2>4. 현실적인 대안: CSS <code>content-visibility</code></h2>
<p>&quot;데이터가 100~200개 정도인데 가상화를 써야 할까?&quot;
이런 고민이 든다면, 가상화는 오버엔지니어링일 확률이 높습니다. 이때 사용할 수 있는 강력한 대안이 CSS의 <strong><code>content-visibility: auto</code></strong> 입니다.</p>
<pre><div style="color:#d4d4d4;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto;background:#1e1e1e"><code class="language-css" style="white-space:pre;color:#ce9178;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span class="token class" style="color:#d7ba7d">.list-item</span><span> </span><span class="token" style="color:#d4d4d4">{</span><span>
</span><span>  </span><span class="token" style="color:#9cdcfe">content-visibility</span><span class="token" style="color:#d4d4d4">:</span><span> auto</span><span class="token" style="color:#d4d4d4">;</span><span>
</span><span>  </span><span class="token" style="color:#9cdcfe">contain-intrinsic-size</span><span class="token" style="color:#d4d4d4">:</span><span> </span><span class="token" style="color:#b5cea8">100</span><span class="token" style="color:#b5cea8">px</span><span class="token" style="color:#d4d4d4">;</span><span> </span><span class="token" style="color:#6a9955">/* 아이템의 예상 높이 */</span><span>
</span><span></span><span class="token" style="color:#d4d4d4">}</span><span>
</span></code></div></pre></div><section class="mt-16 w-full"></section></div><!--$--><!--/$--></main><!--$!--><template data-dgst="BAILOUT_TO_CLIENT_SIDE_RENDERING"></template><!--/$--></div><script src="/_next/static/chunks/8b92303ff08c461e.js" id="_R_" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"1:\"$Sreact.fragment\"\n3:I[27531,[\"/_next/static/chunks/28ff6a04602448ba.js\",\"/_next/static/chunks/64c697a3cb51cd07.js\"],\"default\"]\n4:I[44600,[\"/_next/static/chunks/28ff6a04602448ba.js\",\"/_next/static/chunks/64c697a3cb51cd07.js\"],\"default\"]\n6:I[97990,[\"/_next/static/chunks/28ff6a04602448ba.js\",\"/_next/static/chunks/64c697a3cb51cd07.js\"],\"OutletBoundary\"]\n7:\"$Sreact.suspense\"\n9:I[97990,[\"/_next/static/chunks/28ff6a04602448ba.js\",\"/_next/static/chunks/64c697a3cb51cd07.js\"],\"ViewportBoundary\"]\nb:I[97990,[\"/_next/static/chunks/28ff6a04602448ba.js\",\"/_next/static/chunks/64c697a3cb51cd07.js\"],\"MetadataBoundary\"]\nd:I[60740,[],\"default\"]\n:HL[\"/_next/static/chunks/abdb394ac1358659.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"0:{\"P\":null,\"b\":\"yx8YUX__cxlbsvUkAHFS7\",\"c\":[\"\",\"blog\",\"scroll-virtualization\"],\"q\":\"\",\"i\":false,\"f\":[[[\"\",{\"children\":[\"blog\",{\"children\":[[\"id\",\"scroll-virtualization\",\"d\"],{\"children\":[\"__PAGE__\",{}]}]}]},\"$undefined\",\"$undefined\",true],[[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/chunks/abdb394ac1358659.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}],[\"$\",\"script\",\"script-0\",{\"src\":\"/_next/static/chunks/c6311bd1204a06f2.js\",\"async\":true,\"nonce\":\"$undefined\"}],[\"$\",\"script\",\"script-1\",{\"src\":\"/_next/static/chunks/5ec360913fe0c25f.js\",\"async\":true,\"nonce\":\"$undefined\"}]],\"$L2\"]}],{\"children\":[[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[[\"$\",\"$1\",\"c\",{\"children\":[\"$L5\",[[\"$\",\"script\",\"script-0\",{\"src\":\"/_next/static/chunks/c44bdab66bebb21f.js\",\"async\":true,\"nonce\":\"$undefined\"}]],[\"$\",\"$L6\",null,{\"children\":[\"$\",\"$7\",null,{\"name\":\"Next.MetadataOutlet\",\"children\":\"$@8\"}]}]]}],{},null,false,false]},null,false,false]},null,false,false]},null,false,false],[\"$\",\"$1\",\"h\",{\"children\":[null,[\"$\",\"$L9\",null,{\"children\":\"$La\"}],[\"$\",\"div\",null,{\"hidden\":true,\"children\":[\"$\",\"$Lb\",null,{\"children\":[\"$\",\"$7\",null,{\"name\":\"Next.Metadata\",\"children\":\"$Lc\"}]}]}],null]}],false]],\"m\":\"$undefined\",\"G\":[\"$d\",[]],\"S\":true}\n"])</script><script>self.__next_f.push([1,"e:I[71695,[\"/_next/static/chunks/c6311bd1204a06f2.js\",\"/_next/static/chunks/5ec360913fe0c25f.js\"],\"Sidebar\"]\n"])</script><script>self.__next_f.push([1,"2:[\"$\",\"html\",null,{\"lang\":\"en\",\"children\":[[\"$\",\"link\",null,{\"rel\":\"icon\",\"type\":\"image/svg+xml\",\"href\":\"/vite.svg\"}],[\"$\",\"meta\",null,{\"name\":\"google-site-verification\",\"content\":\"sXxEHSK4sTx3BrDha-kpJpFaszf3wxeSU5ojx8sqq1A\"}],[\"$\",\"body\",null,{\"className\":\"bg-white text-gray-900 dark:bg-gray-900 dark:text-gray-100\",\"children\":[[\"$\",\"script\",null,{\"type\":\"application/ld+json\",\"dangerouslySetInnerHTML\":{\"__html\":\"{\\\"@context\\\":\\\"https://schema.org\\\",\\\"@type\\\":\\\"WebSite\\\",\\\"name\\\":\\\"Dev-Holic Blog\\\",\\\"url\\\":\\\"https://dev-holic.github.io\\\"}\"}}],[\"$\",\"div\",null,{\"className\":\"relative mx-auto flex h-screen w-full max-w-7xl flex-col overflow-hidden md:flex-row\",\"children\":[[\"$\",\"main\",null,{\"className\":\"h-full w-full flex-1 overflow-y-auto\",\"children\":[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":404}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],[]],\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]}],[\"$\",\"$Le\",null,{\"tags\":[\"AI\",\"APM\",\"App Router\",\"Blog\",\"CLI\",\"Datadog\",\"FP\",\"Gemini\",\"Giscus\",\"GitHub Discussions\",\"JavaScript\",\"Monitoring\",\"NPM\",\"Next.js\",\"OOP\",\"RSS\",\"RUM\",\"React Query\",\"Sentry\",\"Singleton\",\"Structure\",\"Symbol.for\",\"Test\",\"Tip\",\"architecture\",\"content-visibility\",\"css\",\"frontend\",\"globalThis\",\"javascript\",\"performance\",\"virtualization\",\"개발\",\"개발 블로그\",\"댓글 시스템\",\"무료\",\"터미널\"]}]]}]]}]]}]\n"])</script><script>self.__next_f.push([1,"f:I[70451,[\"/_next/static/chunks/c6311bd1204a06f2.js\",\"/_next/static/chunks/5ec360913fe0c25f.js\",\"/_next/static/chunks/c44bdab66bebb21f.js\"],\"\"]\n10:I[74553,[\"/_next/static/chunks/c6311bd1204a06f2.js\",\"/_next/static/chunks/5ec360913fe0c25f.js\",\"/_next/static/chunks/c44bdab66bebb21f.js\"],\"PostViewer\"]\n11:T13dd,"])</script><script>self.__next_f.push([1,"\n# 무조건적인 가상화(Virtualization) 도입, 과연 정답일까? (feat. content-visibility)\n\n프론트엔드 개발자라면 긴 리스트를 다룰 때 습관적으로 **\"가상화(Virtualization)를 도입해야겠다\"**고 생각합니다. `react-window`나 `tanstack-virtual` 같은 라이브러리를 설치하는 것이 일종의 'Best Practice'처럼 여겨지죠.\n\n하지만 10년 차 프론트엔드 개발자로서 수많은 프로젝트를 거치며 깨달은 점은, **가상화는 공짜 점심이 아니라는 사실**입니다. 가상화는 성능을 얻는 대신 **UX(사용자 경험)**를 비용으로 지불합니다.\n\n오늘은 리스트 렌더링 성능 최적화의 본질적인 원리와, 가상화가 가진 UX 결함, 그리고 이를 대체할 수 있는 모던 CSS 전략(`content-visibility`)에 대해 이야기해보려 합니다.\n\n---\n\n## 1. 우리는 왜 가상화를 하는가? (본질적인 병목)\n\n데이터가 수천, 수만 개로 늘어날 때 브라우저가 느려지는 진짜 이유는 무엇일까요? 단순히 \"데이터가 많아서\"가 아닙니다.\n\n### DOM 개수의 비대화와 선형적 성능 저하\n가장 큰 문제는 DOM 노드의 개수입니다. 리스트 아이템이 1만 개이고, 각 아이템이 10개의 태그를 가진다면 브라우저는 **10만 개의 DOM 노드**를 메모리에 올리고 관리해야 합니다.\n\n문제는 사용자가 스크롤을 내려 페이지가 쌓일수록 성능 저하가 **선형적(Linear)**으로 발생한다는 점입니다.\n* **Recalculate Style 비용 증가:** 버튼 하나를 클릭해 상태가 바뀌어도, 브라우저는 거대해진 DOM 트리를 순회하며 스타일 계산을 다시 해야 합니다.\n* **메모리 누수:** 화면 밖으로 지나간 수천 개의 이미지와 컴포넌트들이 메모리(RAM/VRAM)를 계속 점유합니다.\n\n가상화(Virtualization)는 이 문제를 해결하기 위해 **\"보이는 영역(Viewport)만 렌더링하고, 벗어난 영역은 DOM에서 제거\"**하는 기술입니다. 덕분에 데이터가 100만 개여도 DOM 노드는 항상 20개 내외로 유지됩니다.\n\n---\n\n## 2. 오해: \"스크롤하면 리페인트(Repaint)가 발생해서 느리다?\"\n\n많은 개발자가 *\"DOM이 많으면 스크롤할 때마다 리페인트가 발생해서 느리다\"*고 오해합니다. 결론부터 말하면 **최신 브라우저에서 최적화된 네이티브 스크롤은 리페인트를 유발하지 않습니다.**\n\n### 브라우저의 스크롤 동작 원리 (Pixel Pipeline)\n1.  **Composite Only:** 브라우저는 스크롤 가능한 영역을 별도의 **레이어(Layer)**로 승격(Promote)시킵니다.\n2.  **GPU 가속:** 이미 그려진(Paint 완료된) 비트맵 텍스처를 GPU가 좌표만 이동시킵니다.\n3.  **결과:** Layout과 Paint 단계를 건너뛰고 **Composite** 단계만 수행하므로 매우 부드럽습니다.\n\n### 그렇다면 가상화 없는 1만 개 리스트는 왜 버벅거릴까?\n리페인트 때문이 아니라, 다른 연산 비용 때문입니다.\n1.  **Hit Testing 과부하:** 스크롤 중 마우스 커서 아래에 어떤 요소가 있는지(Hover, Event 등) 계산해야 하는데, DOM이 1만 개면 이 탐색 비용이 16ms(60fps)를 초과합니다.\n2.  **GPU 대역폭 한계:** 1만 개 분량의 거대한 텍스처를 타일링(Tiling)하고 GPU 메모리로 전송하는 과정에서 병목이 발생합니다.\n3.  **GC(가비지 컬렉션):** 수많은 DOM 노드 참조로 인해 GC 수행 시간이 길어져 스크롤이 턱턱 걸리게 됩니다.\n\n아이러니하게도, **가상화를 적용하면 스크롤할 때마다 필연적으로 리페인트가 발생**합니다. JS가 DOM을 계속 갈아 끼우기 때문이죠. 하지만 \"전체 DOM을 유지하는 비용\"보다 \"작은 영역을 계속 다시 그리는 비용\"이 훨씬 싸기 때문에 가상화를 쓰는 것입니다.\n\n---\n\n## 3. 가상화의 치명적인 단점 (UX Trade-offs)\n\n성능을 위해 가상화를 도입하면 다음과 같은 UX 손해를 감수해야 합니다.\n\n1.  **Ctrl + F (검색) 불가:** DOM에 요소가 없으니 브라우저 기본 찾기 기능으로 내용을 찾을 수 없습니다.\n2.  **스크롤 이질감:** 네이티브 스크롤의 관성, 바운스 등을 JS로 흉내 내야 하므로 미묘하게 어색합니다.\n3.  **스크롤바 널뛰기:** 동적 높이(Dynamic Height) 아이템일 경우, 스크롤바가 떨리거나 위치가 튀는 현상이 발생합니다.\n4.  **빈 화면(White Space):** 스크롤 속도가 렌더링 속도보다 빠르면 하얀 빈 공간이 보입니다.\n\n---\n\n## 4. 현실적인 대안: CSS `content-visibility`\n\n\"데이터가 100~200개 정도인데 가상화를 써야 할까?\"\n이런 고민이 든다면, 가상화는 오버엔지니어링일 확률이 높습니다. 이때 사용할 수 있는 강력한 대안이 CSS의 **`content-visibility: auto`** 입니다.\n\n```css\n.list-item {\n  content-visibility: auto;\n  contain-intrinsic-size: 100px; /* 아이템의 예상 높이 */\n}\n\n```\n"])</script><script>self.__next_f.push([1,"5:[\"$\",\"div\",null,{\"className\":\"mx-auto p-8\",\"children\":[[\"$\",\"script\",null,{\"type\":\"application/ld+json\",\"dangerouslySetInnerHTML\":{\"__html\":\"{\\\"@context\\\":\\\"https://schema.org\\\",\\\"@type\\\":\\\"BlogPosting\\\",\\\"headline\\\":\\\"가상화(Virtualization) 도입, 과연 정답일까? (feat. content-visibility)\\\",\\\"datePublished\\\":\\\"2025-12-20\\\",\\\"dateModified\\\":\\\"2025-12-20\\\",\\\"description\\\":\\\"가상화의 성능상 이점과 UX상의 단점을 살펴보고, content-visibility를 이용한 대안을 제시합니다.\\\",\\\"author\\\":{\\\"@type\\\":\\\"Person\\\",\\\"name\\\":\\\"Dev-Holic\\\"},\\\"url\\\":\\\"https://dev-holic.github.io/blog/scroll-virtualization\\\",\\\"keywords\\\":[\\\"virtualization\\\",\\\"performance\\\",\\\"css\\\",\\\"content-visibility\\\",\\\"frontend\\\"]}\"}}],[\"$\",\"$Lf\",null,{\"href\":\"/\",\"className\":\"mb-4 inline-block text-blue-500 hover:underline\",\"children\":\"← Back to List\"}],[\"$\",\"header\",null,{\"className\":\"mb-8\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"mb-4 text-4xl font-bold text-gray-900 dark:text-gray-100\",\"children\":\"가상화(Virtualization) 도입, 과연 정답일까? (feat. content-visibility)\"}],[\"$\",\"div\",null,{\"className\":\"text-gray-500 dark:text-gray-400\",\"children\":[\"2025-12-20\",[\"$\",\"span\",null,{\"className\":\"ml-2\",\"children\":[\"• \",\"#virtualization #performance #css #content-visibility #frontend\"]}]]}]]}],[\"$\",\"$L10\",null,{\"content\":\"$11\",\"postId\":\"scroll-virtualization\"}],\"$L12\"]}]\n"])</script><script>self.__next_f.push([1,"13:I[65126,[\"/_next/static/chunks/c6311bd1204a06f2.js\",\"/_next/static/chunks/5ec360913fe0c25f.js\",\"/_next/static/chunks/c44bdab66bebb21f.js\"],\"default\"]\n12:[\"$\",\"$L13\",null,{}]\n"])</script><script>self.__next_f.push([1,"a:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"meta\",\"1\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}]]\n"])</script><script>self.__next_f.push([1,"8:null\n"])</script><script>self.__next_f.push([1,"c:[[\"$\",\"title\",\"0\",{\"children\":\"가상화(Virtualization) 도입, 과연 정답일까? (feat. content-visibility) | Dev-Holic Blog\"}],[\"$\",\"meta\",\"1\",{\"name\":\"description\",\"content\":\"가상화의 성능상 이점과 UX상의 단점을 살펴보고, content-visibility를 이용한 대안을 제시합니다.\"}],[\"$\",\"meta\",\"2\",{\"property\":\"og:title\",\"content\":\"Dev-Holic Blog\"}],[\"$\",\"meta\",\"3\",{\"property\":\"og:description\",\"content\":\"Tech, Development, and more\"}],[\"$\",\"meta\",\"4\",{\"property\":\"og:url\",\"content\":\"https://dev-holic.github.io\"}],[\"$\",\"meta\",\"5\",{\"property\":\"og:site_name\",\"content\":\"Dev-Holic Blog\"}],[\"$\",\"meta\",\"6\",{\"property\":\"og:locale\",\"content\":\"ko_KR\"}],[\"$\",\"meta\",\"7\",{\"property\":\"og:image:alt\",\"content\":\"Blog Post Image\"}],[\"$\",\"meta\",\"8\",{\"property\":\"og:image:type\",\"content\":\"image/png\"}],[\"$\",\"meta\",\"9\",{\"property\":\"og:image\",\"content\":\"https://dev-holic.github.io/blog/scroll-virtualization/opengraph-image?a07550892c625387\"}],[\"$\",\"meta\",\"10\",{\"property\":\"og:image:width\",\"content\":\"1200\"}],[\"$\",\"meta\",\"11\",{\"property\":\"og:image:height\",\"content\":\"630\"}],[\"$\",\"meta\",\"12\",{\"property\":\"og:type\",\"content\":\"website\"}],[\"$\",\"meta\",\"13\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"$\",\"meta\",\"14\",{\"name\":\"twitter:title\",\"content\":\"Dev-Holic Blog\"}],[\"$\",\"meta\",\"15\",{\"name\":\"twitter:description\",\"content\":\"Tech, Development, and more\"}],[\"$\",\"meta\",\"16\",{\"name\":\"twitter:image:alt\",\"content\":\"Blog Post Image\"}],[\"$\",\"meta\",\"17\",{\"name\":\"twitter:image:type\",\"content\":\"image/png\"}],[\"$\",\"meta\",\"18\",{\"name\":\"twitter:image\",\"content\":\"https://dev-holic.github.io/blog/scroll-virtualization/opengraph-image?a07550892c625387\"}],[\"$\",\"meta\",\"19\",{\"name\":\"twitter:image:width\",\"content\":\"1200\"}],[\"$\",\"meta\",\"20\",{\"name\":\"twitter:image:height\",\"content\":\"630\"}]]\n"])</script></body></html>