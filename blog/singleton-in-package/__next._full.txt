1:"$Sreact.fragment"
3:I[27531,["/_next/static/chunks/28ff6a04602448ba.js","/_next/static/chunks/64c697a3cb51cd07.js"],"default"]
4:I[44600,["/_next/static/chunks/28ff6a04602448ba.js","/_next/static/chunks/64c697a3cb51cd07.js"],"default"]
6:I[97990,["/_next/static/chunks/28ff6a04602448ba.js","/_next/static/chunks/64c697a3cb51cd07.js"],"OutletBoundary"]
7:"$Sreact.suspense"
9:I[97990,["/_next/static/chunks/28ff6a04602448ba.js","/_next/static/chunks/64c697a3cb51cd07.js"],"ViewportBoundary"]
b:I[97990,["/_next/static/chunks/28ff6a04602448ba.js","/_next/static/chunks/64c697a3cb51cd07.js"],"MetadataBoundary"]
d:I[60740,[],"default"]
:HL["/_next/static/chunks/abdb394ac1358659.css","style"]
0:{"P":null,"b":"yx8YUX__cxlbsvUkAHFS7","c":["","blog","singleton-in-package"],"q":"","i":false,"f":[[["",{"children":["blog",{"children":[["id","singleton-in-package","d"],{"children":["__PAGE__",{}]}]}]},"$undefined","$undefined",true],[["$","$1","c",{"children":[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/chunks/abdb394ac1358659.css","precedence":"next","crossOrigin":"$undefined","nonce":"$undefined"}],["$","script","script-0",{"src":"/_next/static/chunks/c6311bd1204a06f2.js","async":true,"nonce":"$undefined"}],["$","script","script-1",{"src":"/_next/static/chunks/5ec360913fe0c25f.js","async":true,"nonce":"$undefined"}]],"$L2"]}],{"children":[["$","$1","c",{"children":[null,["$","$L3",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L4",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]]}],{"children":[["$","$1","c",{"children":[null,["$","$L3",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L4",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]]}],{"children":[["$","$1","c",{"children":["$L5",[["$","script","script-0",{"src":"/_next/static/chunks/c44bdab66bebb21f.js","async":true,"nonce":"$undefined"}]],["$","$L6",null,{"children":["$","$7",null,{"name":"Next.MetadataOutlet","children":"$@8"}]}]]}],{},null,false,false]},null,false,false]},null,false,false]},null,false,false],["$","$1","h",{"children":[null,["$","$L9",null,{"children":"$La"}],["$","div",null,{"hidden":true,"children":["$","$Lb",null,{"children":["$","$7",null,{"name":"Next.Metadata","children":"$Lc"}]}]}],null]}],false]],"m":"$undefined","G":["$d",[]],"S":true}
e:I[71695,["/_next/static/chunks/c6311bd1204a06f2.js","/_next/static/chunks/5ec360913fe0c25f.js"],"Sidebar"]
2:["$","html",null,{"lang":"en","children":[["$","link",null,{"rel":"icon","type":"image/svg+xml","href":"/vite.svg"}],["$","meta",null,{"name":"google-site-verification","content":"sXxEHSK4sTx3BrDha-kpJpFaszf3wxeSU5ojx8sqq1A"}],["$","body",null,{"className":"bg-white text-gray-900 dark:bg-gray-900 dark:text-gray-100","children":[["$","script",null,{"type":"application/ld+json","dangerouslySetInnerHTML":{"__html":"{\"@context\":\"https://schema.org\",\"@type\":\"WebSite\",\"name\":\"Dev-Holic Blog\",\"url\":\"https://dev-holic.github.io\"}"}}],["$","div",null,{"className":"relative mx-auto flex h-screen w-full max-w-7xl flex-col overflow-hidden md:flex-row","children":[["$","main",null,{"className":"h-full w-full flex-1 overflow-y-auto","children":["$","$L3",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L4",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":[[["$","title",null,{"children":"404: This page could not be found."}],["$","div",null,{"style":{"fontFamily":"system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"","height":"100vh","textAlign":"center","display":"flex","flexDirection":"column","alignItems":"center","justifyContent":"center"},"children":["$","div",null,{"children":[["$","style",null,{"dangerouslySetInnerHTML":{"__html":"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}"}}],["$","h1",null,{"className":"next-error-h1","style":{"display":"inline-block","margin":"0 20px 0 0","padding":"0 23px 0 0","fontSize":24,"fontWeight":500,"verticalAlign":"top","lineHeight":"49px"},"children":404}],["$","div",null,{"style":{"display":"inline-block"},"children":["$","h2",null,{"style":{"fontSize":14,"fontWeight":400,"lineHeight":"49px","margin":0},"children":"This page could not be found."}]}]]}]}]],[]],"forbidden":"$undefined","unauthorized":"$undefined"}]}],["$","$Le",null,{"tags":["AI","APM","App Router","Blog","CLI","Datadog","FP","Gemini","Giscus","GitHub Discussions","JavaScript","Monitoring","NPM","Next.js","OOP","RSS","RUM","React Query","Sentry","Singleton","Structure","Symbol.for","Test","Tip","architecture","content-visibility","css","frontend","globalThis","javascript","performance","virtualization","개발","개발 블로그","댓글 시스템","무료","터미널"]}]]}]]}]]}]
f:I[70451,["/_next/static/chunks/c6311bd1204a06f2.js","/_next/static/chunks/5ec360913fe0c25f.js","/_next/static/chunks/c44bdab66bebb21f.js"],""]
10:I[74553,["/_next/static/chunks/c6311bd1204a06f2.js","/_next/static/chunks/5ec360913fe0c25f.js","/_next/static/chunks/c44bdab66bebb21f.js"],"PostViewer"]
11:T1f43,
# [Architecture] NPM 패키지 분리 환경에서 싱글톤(Singleton) 유지하기: globalThis와 Symbol.for의 활용

최근 사내 패키지 배포 구조를 개선하면서 마주친 문제와 그 해결 과정을 공유합니다.

여러 프로젝트에서 공통으로 사용하는 패키지들을 npm 저장소(Nexus 등)에 배포하여 관리하고 있는데, 배포 편의성을 위해 의존성 패키지를 번들(Bundle)에 포함시키는 과정에서 **싱글톤(Singleton) 객체가 유지되지 않는 이슈**가 발생했습니다.

이 글에서는 물리적으로 분리된 번들 환경에서 어떻게 안전하게 싱글톤 인스턴스를 공유했는지, 그 과정에서 **`globalThis`**와 **`Symbol.for`**를 어떻게 활용했는지 다룹니다.

## 1. 문제 상황 (The Problem)

### 아키텍처 구조
현재 우리 팀은 다음과 같은 3가지 패키지를 운용하고 있습니다.

* **Framework**: 핵심 로직과 싱글톤 객체(Store, Manager 등)를 제공
* **Editor**: `Framework`를 의존하여 사용하는 편집 도구
* **Converter**: `Framework`를 의존하여 사용하는 변환 도구

배포 및 설치 편의성을 위해 `Editor`와 `Converter`를 배포할 때, 이들이 의존하는 `Framework` 코드를 각각의 번들에 포함(Bundled)시켜 배포했습니다.

### 발생한 이슈
호스트 애플리케이션에서 `Editor`와 `Converter`를 동시에 설치해서 사용할 때 문제가 발생했습니다.

1.  `Editor`가 로드되면서 내부의 `Framework`가 초기화됨 (싱글톤 A 생성)
2.  `Converter`가 로드되면서 내부의 `Framework`가 초기화됨 (싱글톤 B 생성)
3.  **결과:** 두 패키지가 **서로 다른 싱글톤 인스턴스**를 바라보게 되어 상태 공유가 불가능해짐.

## 2. 원인 분석

일반적인 ES Module 시스템에서 싱글톤은 **모듈 스코프(Module Scope)** 내의 클로저를 통해 유지됩니다.

하지만 번들링을 하게 되면 각 번들 파일(`editor.bundle.js`, `converter.bundle.js`)마다 `Framework`의 코드가 복제되어 들어갑니다. 자바스크립트 런타임 입장에서 이 두 코드는 **서로 다른 물리적 모듈**로 취급되므로, 각각 별도의 실행 컨텍스트와 메모리 공간을 갖게 됩니다.

따라서 모듈 시스템의 스코프를 넘어선 **전역 공간(Global Scope)**을 통한 상태 공유가 필요했습니다.

## 3. 해결 전략: Global Scope 활용

### 1차 접근: 전역 객체(globalThis) 사용
브라우저와 Node.js 환경 모두를 아우를 수 있는 표준인 `globalThis`에 인스턴스를 저장하기로 했습니다.

```typescript
// 단순히 문자열 키를 사용한다면?
globalThis['MY_FRAMEWORK_INSTANCE'] = new Framework();
```

하지만 단순히 문자열 키(`string key`)를 사용하는 것은 다음과 같은 위험이 있습니다.
* **이름 충돌:** 다른 라이브러리나 레거시 코드에서 우연히 같은 이름을 사용할 경우 덮어씌워질 위험이 있음.
* **전역 오염:** `Object.keys(window)` 등으로 조회했을 때 노출되어, 의도치 않은 접근이나 수정이 발생할 수 있음.

### 2차 접근: Symbol.for() 활용 (최종 솔루션)
이 문제를 해결하기 위해 **`Symbol.for()`**를 사용했습니다.

* **Namespace 격리:** Symbol은 일반 문자열 키와 다른 레이어에 저장되므로, 일반적인 전역 변수 접근으로 오염될 일이 없습니다.
* **Cross-Realm 공유:** `Symbol()`은 호출할 때마다 매번 다른 값을 만들지만, `Symbol.for('key')`는 **전역 심볼 레지스트리**를 통해 키가 같으면 동일한 심볼 객체를 반환합니다. 즉, **번들이 달라도 같은 심볼을 가리킬 수 있습니다.**

## 4. 구현 코드 (Implementation)

기존의 싱글톤 레지스트리 패턴에 `globalThis`와 `Symbol.for`를 적용한 구현입니다.

### SingletonRegistry.ts

```typescript
// 1. 전역에서 유일성을 보장하기 위한 Symbol 키 생성
// 충돌 방지를 위해 회사 도메인 등을 포함한 긴 네이밍 권장
const CONSTRUCTORS_KEY = Symbol.for('my-org.framework.registry.constructors');
const SINGLETONS_KEY = Symbol.for('my-org.framework.registry.singletons');

// 2. 전역 객체 타입 정의 (TypeScript)
type GlobalWithRegistry = typeof globalThis & {
  [CONSTRUCTORS_KEY]?: Map<string, new (...args: any[]) => any>;
  [SINGLETONS_KEY]?: Map<string, any>;
};

// 3. 전역 맵 접근 헬퍼 (초기화 로직 포함)
function getGlobalSingletons(): Map<string, any> {
  const g = globalThis as GlobalWithRegistry;
  if (!g[SINGLETONS_KEY]) {
    g[SINGLETONS_KEY] = new Map();
  }
  return g[SINGLETONS_KEY]!;
}

// ... 생성자 맵 접근 함수도 동일한 방식 ...

export namespace SingletonRegistry {
  export const register = (name: string, constructor: new (...args: any[]) => any) => {
    // 로컬 변수가 아닌 전역 심볼 맵에 저장
    getGlobalConstructors().set(name, constructor);
  };

  export const resolve = (name: string) => {
    const singletons = getGlobalSingletons();
    
    // 이미 생성된 인스턴스가 전역 맵에 있는지 확인
    if (!singletons.has(name)) {
      const constructors = getGlobalConstructors();
      const constructor = constructors.get(name);
      
      if (!constructor) {
        throw new Error(`Singleton ${name} is not registered`);
      }
      
      // 인스턴스 생성 후 전역 맵에 저장 -> 다른 번들에서도 이 인스턴스를 보게 됨 
      singletons.set(name, new constructor());
    }

    return singletons.get(name);
  };
}
```

이렇게 구현하면 `Editor` 번들에서 먼저 `resolve`를 호출해 인스턴스를 만들면, 나중에 로드된 `Converter` 번들에서도 `globalThis`의 심볼 키를 통해 **동일한 인스턴스**를 찾아 반환하게 됩니다.

## 5. 주의사항 및 한계 (Trade-offs)

이 방식은 유용한 "탈출구(Escape Hatch)"이지만, 몇 가지 주의할 점이 있습니다.

### 1) `instanceof` 체크 불가
서로 다른 번들에서 로드된 클래스는 내용은 같아도 자바스크립트 엔진상 **다른 생성자 함수**입니다. 따라서 `resolve()`로 가져온 객체에 대해 `instanceof` 검사를 하면 `false`가 나올 수 있습니다.
* **해결:** 타입 체크가 필요하다면 `instanceof` 대신 **Duck Typing**이나 공통 **Interface**를 사용해야 합니다.

### 2) 버전 관리 (Version Mismatch)
만약 `Editor`는 Framework v1.0을, `Converter`는 Framework v2.0을 번들링하고 있다면 런타임 에러가 발생할 수 있습니다. (v1 인스턴스가 전역에 있는데 v2 메서드를 호출하는 경우 등)
* **해결:** 모든 패키지가 동일한 버전의 Framework를 사용하도록 CI 단계에서 엄격하게 관리하거나, 심볼 키에 버전을 명시(`Symbol.for('...v1')`)하여 격리해야 합니다.

### 3) 테스트 격리
단위 테스트(Jest/Vitest) 실행 시 `globalThis`가 오염되어 테스트 간 간섭이 발생할 수 있습니다. `afterEach` 등에서 전역 심볼 맵을 초기화해주는 작업이 필요합니다.

## 6. 결론

NPM 패키지 배포 시 번들링 전략에 따라 싱글톤 패턴이 깨지는 문제는 흔히 발생할 수 있습니다. 가장 정석적인 방법은 `peerDependencies`를 사용하여 호스트가 단일 버전을 설치하게 하는 것이지만, 배포 및 사용 편의성을 위해 번들링이 필수적인 상황이라면 **`globalThis`와 `Symbol.for`를 활용한 전역 레지스트리 패턴**이 훌륭한 해결책이 될 수 있습니다.

이 패턴은 React, Styled-components 등 유명 라이브러리들에서도 런타임 환경의 제약을 극복하기 위해 내부적으로 사용하는 검증된 방식입니다. 다만, 사용 시 발생할 수 있는 사이드 이펙트(버전, 타입 체크)를 충분히 인지하고 적용해야 합니다.
5:["$","div",null,{"className":"mx-auto p-8","children":[["$","script",null,{"type":"application/ld+json","dangerouslySetInnerHTML":{"__html":"{\"@context\":\"https://schema.org\",\"@type\":\"BlogPosting\",\"headline\":\"NPM 패키지 분리 환경에서 싱글톤(Singleton) 유지하기: globalThis와 Symbol.for의 활용\",\"datePublished\":\"2025-12-20\",\"dateModified\":\"2025-12-20\",\"description\":\"물리적으로 분리된 번들 환경에서 globalThis와 Symbol.for를 활용하여 싱글톤 인스턴스를 안전하게 공유하는 방법을 설명합니다.\",\"author\":{\"@type\":\"Person\",\"name\":\"Dev-Holic\"},\"url\":\"https://dev-holic.github.io/blog/singleton-in-package\",\"keywords\":[\"NPM\",\"Singleton\",\"globalThis\",\"Symbol.for\",\"JavaScript\"]}"}}],["$","$Lf",null,{"href":"/","className":"mb-4 inline-block text-blue-500 hover:underline","children":"← Back to List"}],["$","header",null,{"className":"mb-8","children":[["$","h1",null,{"className":"mb-4 text-4xl font-bold text-gray-900 dark:text-gray-100","children":"NPM 패키지 분리 환경에서 싱글톤(Singleton) 유지하기: globalThis와 Symbol.for의 활용"}],["$","div",null,{"className":"text-gray-500 dark:text-gray-400","children":["2025-12-20",["$","span",null,{"className":"ml-2","children":["• ","#NPM #Singleton #globalThis #Symbol.for #JavaScript"]}]]}]]}],["$","$L10",null,{"content":"$11","postId":"singleton-in-package"}],"$L12"]}]
13:I[65126,["/_next/static/chunks/c6311bd1204a06f2.js","/_next/static/chunks/5ec360913fe0c25f.js","/_next/static/chunks/c44bdab66bebb21f.js"],"default"]
12:["$","$L13",null,{}]
a:[["$","meta","0",{"charSet":"utf-8"}],["$","meta","1",{"name":"viewport","content":"width=device-width, initial-scale=1"}]]
8:null
c:[["$","title","0",{"children":"NPM 패키지 분리 환경에서 싱글톤(Singleton) 유지하기: globalThis와 Symbol.for의 활용 | Dev-Holic Blog"}],["$","meta","1",{"name":"description","content":"물리적으로 분리된 번들 환경에서 globalThis와 Symbol.for를 활용하여 싱글톤 인스턴스를 안전하게 공유하는 방법을 설명합니다."}],["$","meta","2",{"property":"og:title","content":"Dev-Holic Blog"}],["$","meta","3",{"property":"og:description","content":"Tech, Development, and more"}],["$","meta","4",{"property":"og:url","content":"https://dev-holic.github.io"}],["$","meta","5",{"property":"og:site_name","content":"Dev-Holic Blog"}],["$","meta","6",{"property":"og:locale","content":"ko_KR"}],["$","meta","7",{"property":"og:image:alt","content":"Blog Post Image"}],["$","meta","8",{"property":"og:image:type","content":"image/png"}],["$","meta","9",{"property":"og:image","content":"https://dev-holic.github.io/blog/singleton-in-package/opengraph-image?a07550892c625387"}],["$","meta","10",{"property":"og:image:width","content":"1200"}],["$","meta","11",{"property":"og:image:height","content":"630"}],["$","meta","12",{"property":"og:type","content":"website"}],["$","meta","13",{"name":"twitter:card","content":"summary_large_image"}],["$","meta","14",{"name":"twitter:title","content":"Dev-Holic Blog"}],["$","meta","15",{"name":"twitter:description","content":"Tech, Development, and more"}],["$","meta","16",{"name":"twitter:image:alt","content":"Blog Post Image"}],["$","meta","17",{"name":"twitter:image:type","content":"image/png"}],["$","meta","18",{"name":"twitter:image","content":"https://dev-holic.github.io/blog/singleton-in-package/opengraph-image?a07550892c625387"}],["$","meta","19",{"name":"twitter:image:width","content":"1200"}],["$","meta","20",{"name":"twitter:image:height","content":"630"}]]
