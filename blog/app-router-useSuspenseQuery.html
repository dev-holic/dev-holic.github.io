<!DOCTYPE html><!--xcUo785Y1ppM0QMMmzB_a--><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="/_next/static/chunks/78e1cd5791fa066e.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/a493a3c4f2b38b68.js"/><script src="/_next/static/chunks/448036de9651b639.js" async=""></script><script src="/_next/static/chunks/d87cd5742aeed2ef.js" async=""></script><script src="/_next/static/chunks/cd780e53bafce20d.js" async=""></script><script src="/_next/static/chunks/turbopack-581238609d983bc1.js" async=""></script><script src="/_next/static/chunks/28ff6a04602448ba.js" async=""></script><script src="/_next/static/chunks/64c697a3cb51cd07.js" async=""></script><script src="/_next/static/chunks/0d67ebe65980c00f.js" async=""></script><script src="/_next/static/chunks/8307872c0df20eb5.js" async=""></script><link rel="icon" type="image/svg+xml" href="/vite.svg"/><title>Dev-Holic Blog</title><meta name="description" content="Dev-Holic Blog"/><script src="/_next/static/chunks/a6dad97d9634a72d.js" noModule=""></script></head><body class="bg-white dark:bg-gray-900 text-gray-900 dark:text-gray-100"><div hidden=""><!--$--><!--/$--></div><div class="p-8 max-w-4xl mx-auto"><a class="text-blue-500 hover:underline mb-4 inline-block" href="/">← Back to List</a><header class="mb-8"><h1 class="text-4xl font-bold mb-4 text-gray-900 dark:text-gray-100">Next.js App Router: useSuspenseQuery 서버 행(Hanging) 이슈 해결</h1><div class="text-gray-500 dark:text-gray-400">2025-12-20<span class="ml-2">• <!-- -->#Next.js #React Query #App Router</span></div></header><div class="prose prose-lg dark:prose-invert max-w-none"><ol>
<li>서론: 끝나지 않는 로딩의 미스터리</li>
</ol>
<p>Next.js App Router는 서버 컴포넌트와 클라이언트 컴포넌트의 유연한 조합을 통해 강력한 웹 애플리케이션 구축을 가능하게 합니다. 하지만 이 새로운 렌더링 패러다임은 강력한 만큼, 기존의 클라이언트 중심 멘탈 모델과 충돌하며 흔한 함정을 만들어냅니다. 그 대표적인 사례가 바로 @tanstack/react-query의 useSuspenseQuery를 클라이언트 컴포넌트에서 사용했을 때 발생하는 &#x27;서버 행(Hanging)&#x27; 현상, 즉 페이지 응답이 멈추고 무한 로딩에 빠지는 문제입니다.</p>
<p>이 글은 이 문제를 단순한 버그가 아닌, 서버 우선 렌더링 모델과 클라이언트 데이터 페칭 패턴이 충돌할 때 발생하는 예측 가능한 결과로 분석합니다. 우리는 이 현상의 근본 원인을 명확히 파헤치고, next/dynamic을 활용해 의도적인 렌더링 경계를 설정하는 확실한 해결책을 제시할 것입니다. 이제 문제 상황을 구체적으로 재현하며 본격적인 분석을 시작하겠습니다.</p>
<ol start="2">
<li>문제 현상 분석: useSuspenseQuery가 서버를 멈추게 할 때</li>
</ol>
<p>모든 문제 해결의 첫걸음은 현상을 명확하게 정의하고 재현하는 것입니다. 정확한 진단 없이는 올바른 처방을 내릴 수 없기 때문입니다. 어떤 환경과 코드 구조에서 이 문제가 발생하는지 구체적으로 살펴보겠습니다.</p>
<p>문제는 다음과 같은 시나리오에서 발생합니다.</p>
<ul>
<li>환경: Next.js App Router</li>
<li>구조: 서버 컴포넌트(Server Component)가 <code>&lt;Suspense&gt;</code> fallback UI로 클라이언트 컴포넌트(Client Component)를 감싸는 구조</li>
<li>핵심 원인: 감싸진 클라이언트 컴포넌트 내부에서 @tanstack/react-query의 useSuspenseQuery를 호출함</li>
</ul>
<p>이 조건들이 충족될 때 나타나는 가장 명백한 증상은 다음과 같습니다. 페이지 응답이 완료되지 않고 브라우저 탭의 파비콘이 계속 로딩 상태로 남아있는 &#x27;서버 행(Hanging)&#x27; 현상이 발생합니다. 사용자는 아무런 콘텐츠도 보지 못한 채 끝없이 기다리게 되고, 개발자 도구의 네트워크 탭을 봐도 응답이 오지 않는 것을 확인할 수 있습니다.</p>
<p>이처럼 서버가 응답을 멈추는 현상은 왜 발생하는 것일까요? 이 근본적인 원인을 파헤치기 위해서는, 우리가 흔히 오해하는 클라이언트 컴포넌트의 렌더링 방식에 대한 정확한 이해가 필요합니다.</p>
<ol start="3">
<li>근본 원인 탐구: &#x27;use client&#x27;의 오해와 진실</li>
</ol>
<p>단순히 현상을 해결하는 것을 넘어, Next.js App Router의 핵심 렌더링 메커니즘을 이해하는 것은 매우 중요합니다. 이번 문제의 근원은 바로 &#x27;use client&#x27; 지시어에 대한 흔한 오해에서 비롯됩니다.</p>
<p>&#x27;use client&#x27;는 CSR을 의미하지 않는다</p>
<p>많은 개발자가 &#x27;use client&#x27; 지시어를 파일 상단에 추가하면 해당 컴포넌트가 오직 브라우저에서만 렌더링(Client-Side Rendering, CSR)될 것이라고 생각합니다. 하지만 이는 사실이 아닙니다. 이 동작은 Next.js에 국한된 것이 아니라, React 18의 Suspense 기반 SSR의 고유한 특성입니다. &#x27;use client&#x27;의 정확한 의미는 다음과 같습니다.</p>
<ul>
<li>Pre-rendering (사전 렌더링): &#x27;use client&#x27;로 명시된 컴포넌트조차도, 최초 페이지 로드 시에는 서버에서 초기 HTML 뼈대를 미리 렌더링(Server-Side Rendering, SSR)합니다.</li>
<li>Hydration (하이드레이션): 이후 브라우저에서 JavaScript 번들이 로드되면, 서버가 생성한 HTML 위에 이벤트 핸들러 등을 연결하여 상호작용이 가능한 완전한 컴포넌트로 &#x27;깨우는&#x27; 과정을 거칠니다.</li>
</ul>
<p>즉, 별도의 설정이 없는 한 모든 클라이언트 컴포넌트는 서버에서 최소 한 번 실행됩니다. 바로 이 지점이 useSuspenseQuery가 서버 행을 유발하는 원인입니다. 그 메커니즘은 다음과 같습니다.</p>
<ol>
<li>서버 렌더링 시도: 사용자가 페이지에 접속하면, Next.js 서버는 UI를 구성하는 클라이언트 컴포넌트의 최초 HTML 렌더링을 시도합니다.</li>
<li>데이터 부재와 Suspend: 서버 환경에는 react-query가 관리하는 클라이언트 측 캐시 데이터가 존재하지 않습니다. 따라서 useSuspenseQuery는 데이터를 가져오기 위해 Promise를 던지고(throw), 컴포넌트를 &#x27;Suspend(일시 중단)&#x27; 상태로 만듭니다.</li>
<li>무한 대기: 서버에 있는 부모 <code>&lt;Suspense&gt;</code> 경계가 이 Promise를 감지합니다. 이는 Next.js 서버의 렌더러에게 &quot;이 부분의 HTML 생성을 중단하고 Promise가 해결될 때까지 기다려라&quot;는 신호입니다. 하지만 이 Promise는 클라이언트 사이드 데이터 페칭 로직이므로 서버에서는 절대 해결될 수 없습니다. 결과적으로, Next.js 서버의 응답 스트림 전송이 중단된 채 무기한 대기하게 되는 &#x27;행(Hanging)&#x27; 상태에 빠집니다.</li>
</ol>
<p>결국 문제의 원인은 클라이언트에서만 실행되어야 할 데이터 페칭 로직이 서버 렌더링 과정 중 시도되었기 때문입니다. 이를 해결하기 위한 전략은 명확합니다. 해당 컴포넌트의 서버 렌더링 자체를 의도적으로 비활성화하는 것입니다.</p>
<ol start="4">
<li>해결책 제시: next/dynamic과 ssr: false 옵션</li>
</ol>
<p>문제의 원인이 서버 렌더링 시도에 있다는 것을 파악했으니, 이제 명확한 해결책을 제시할 차례입니다. 우리는 해당 컴포넌트를 기본 SSR/Hydration 모델에서 의도적으로 제외하고, 순수한 클라이언트 사이드 렌더링(CSR) 경계를 설정해야 합니다.</p>
<p>이때 사용할 수 있는 가장 강력한 도구가 바로 Next.js의 내장 기능인 next/dynamic입니다. next/dynamic은 컴포넌트를 동적으로 임포트하게 해주며, 특히 ssr: false 옵션과 함께 사용될 때 이 문제의 완벽한 해결책이 됩니다.</p>
<p>ssr: false 옵션의 역할은 매우 직관적입니다. 이것은 Next.js 서버에게 **&quot;이 컴포넌트의 HTML은 미리 만들지 말고, 브라우저에서 JavaScript가 로드된 후에 렌더링을 시작하라&quot;**고 명확히 지시하는 것과 같습니다.</p>
<p>이 해결책을 적용했을 때 얻게 되는 결과는 다음과 같습니다.</p>
<ul>
<li>서버는 해당 컴포넌트의 렌더링을 완전히 건너뛰고 나머지 페이지의 HTML을 구성하여 즉시 클라이언트에 응답을 보냅니다.</li>
<li>클라이언트(브라우저)는 초기 HTML을 받은 후, 해당 컴포넌트의 JavaScript 코드를 비동기적으로 로드합니다.</li>
<li>로드가 완료되면, 실제 데이터 페칭(useSuspenseQuery)과 렌더링은 온전히 클라이언트 환경에서만 일어나므로 서버 행 이슈가 근본적으로 해결됩니다.</li>
</ul>
<p>이론적 설명을 마쳤으니, 이제 실제 코드를 통해 이 해결책을 어떻게 적용하는지 구체적으로 살펴보겠습니다.</p>
<ol start="5">
<li>적용 코드 예시: 문제 해결의 실제</li>
</ol>
<p>앞서 설명한 해결책을 실제 코드에 어떻게 적용하는지 보여드리겠습니다. 부모인 서버 컴포넌트에서 useSuspenseQuery를 사용하는 자식 클라이언트 컴포넌트를 불러오는 방식을 어떻게 변경하는지 집중해서 보시기 바랍니다.</p>
<p>먼저 부모 컴포넌트인 <strong>ServerComponent.tsx</strong>의 변경 사항입니다. import 구문을 next/dynamic으로 대체하고 ssr: false 옵션을 추가합니다.</p>
<pre><div style="color:#d4d4d4;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto;background:#1e1e1e"><code class="language-typescript" style="white-space:pre;color:#9cdcfe;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span class="token" style="color:#6a9955">// ServerComponent.tsx (부모 컴포넌트)</span><span>
</span><span></span><span class="token" style="color:#c586c0">import</span><span> </span><span class="token">dynamic</span><span> </span><span class="token" style="color:#c586c0">from</span><span> </span><span class="token" style="color:#ce9178">&#x27;next/dynamic&#x27;</span><span class="token" style="color:#d4d4d4">;</span><span>
</span>
<span></span><span class="token" style="color:#6a9955">// 핵심: ssr: false 옵션으로 서버 렌더링을 비활성화</span><span>
</span><span></span><span class="token" style="color:#569CD6">const</span><span> </span><span class="token" style="color:#4ec9b0">ClientComponentWithNoSSR</span><span> </span><span class="token" style="color:#d4d4d4">=</span><span> </span><span class="token" style="color:#dcdcaa">dynamic</span><span class="token" style="color:#d4d4d4">(</span><span>
</span><span>  </span><span class="token" style="color:#d4d4d4">(</span><span class="token" style="color:#d4d4d4">)</span><span> </span><span class="token" style="color:#569CD6">=&gt;</span><span> </span><span class="token" style="color:#c586c0">import</span><span class="token" style="color:#d4d4d4">(</span><span class="token" style="color:#ce9178">&#x27;./ClientComponent&#x27;</span><span class="token" style="color:#d4d4d4">)</span><span class="token" style="color:#d4d4d4">,</span><span>
</span><span>  </span><span class="token" style="color:#d4d4d4">{</span><span>
</span><span>    ssr</span><span class="token" style="color:#d4d4d4">:</span><span> </span><span class="token" style="color:#569cd6">false</span><span class="token" style="color:#d4d4d4">,</span><span>
</span><span>    </span><span class="token" style="color:#6a9955">// 컴포넌트의 JS가 로드되는 동안 보여줄 UI</span><span>
</span><span>    </span><span class="token function-variable" style="color:#dcdcaa">loading</span><span class="token" style="color:#d4d4d4">:</span><span> </span><span class="token" style="color:#d4d4d4">(</span><span class="token" style="color:#d4d4d4">)</span><span> </span><span class="token" style="color:#569CD6">=&gt;</span><span> </span><span class="token" style="color:#d4d4d4">&lt;</span><span>p</span><span class="token" style="color:#d4d4d4">&gt;</span><span class="token" style="color:#4ec9b0">Loading</span><span class="token spread" style="color:#d4d4d4">...</span><span class="token" style="color:#d4d4d4">&lt;</span><span class="token" style="color:#d4d4d4">/</span><span>p</span><span class="token" style="color:#d4d4d4">&gt;</span><span class="token" style="color:#d4d4d4">,</span><span>
</span><span>  </span><span class="token" style="color:#d4d4d4">}</span><span>
</span><span></span><span class="token" style="color:#d4d4d4">)</span><span class="token" style="color:#d4d4d4">;</span><span>
</span>
<span></span><span class="token" style="color:#c586c0">export</span><span> </span><span class="token" style="color:#c586c0">default</span><span> </span><span class="token" style="color:#569CD6">function</span><span> </span><span class="token" style="color:#dcdcaa">Page</span><span class="token" style="color:#d4d4d4">(</span><span class="token" style="color:#d4d4d4">)</span><span> </span><span class="token" style="color:#d4d4d4">{</span><span>
</span><span>  </span><span class="token" style="color:#c586c0">return</span><span> </span><span class="token" style="color:#d4d4d4">(</span><span>
</span><span>    </span><span class="token" style="color:#d4d4d4">&lt;</span><span>div</span><span class="token" style="color:#d4d4d4">&gt;</span><span>
</span><span>      </span><span class="token" style="color:#d4d4d4">&lt;</span><span>h1</span><span class="token" style="color:#d4d4d4">&gt;</span><span class="token" style="color:#4ec9b0">My</span><span> </span><span class="token" style="color:#4ec9b0">Page</span><span class="token" style="color:#d4d4d4">&lt;</span><span class="token" style="color:#d4d4d4">/</span><span>h1</span><span class="token" style="color:#d4d4d4">&gt;</span><span>
</span><span>      </span><span class="token" style="color:#d4d4d4">{</span><span class="token" style="color:#6a9955">/* 서버 행 이슈 없이 클라이언트에서만 렌더링됩니다. */</span><span class="token" style="color:#d4d4d4">}</span><span>
</span><span>      </span><span class="token" style="color:#d4d4d4">&lt;</span><span class="token" style="color:#4ec9b0">ClientComponentWithNoSSR</span><span> </span><span class="token" style="color:#d4d4d4">/</span><span class="token" style="color:#d4d4d4">&gt;</span><span>
</span><span>    </span><span class="token" style="color:#d4d4d4">&lt;</span><span class="token" style="color:#d4d4d4">/</span><span>div</span><span class="token" style="color:#d4d4d4">&gt;</span><span>
</span><span>  </span><span class="token" style="color:#d4d4d4">)</span><span class="token" style="color:#d4d4d4">;</span><span>
</span><span></span><span class="token" style="color:#d4d4d4">}</span></code></div></pre>
<p>다음은 <strong>ClientComponent.tsx</strong>의 코드입니다. 흥미롭게도 이 컴포넌트의 코드는 전혀 변경할 필요가 없습니다. next/dynamic을 통해 렌더링 제어의 책임이 부모 컴포넌트로 넘어갔기 때문입니다.</p>
<pre><div style="color:#d4d4d4;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto;background:#1e1e1e"><code class="language-typescript" style="white-space:pre;color:#9cdcfe;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span class="token" style="color:#6a9955">// ClientComponent.tsx (자식 컴포넌트)</span><span>
</span><span></span><span class="token" style="color:#ce9178">&#x27;use client&#x27;</span><span class="token" style="color:#d4d4d4">;</span><span>
</span>
<span></span><span class="token" style="color:#c586c0">import</span><span> </span><span class="token" style="color:#d4d4d4">{</span><span class="token"> useSuspenseQuery </span><span class="token" style="color:#d4d4d4">}</span><span> </span><span class="token" style="color:#c586c0">from</span><span> </span><span class="token" style="color:#ce9178">&#x27;@tanstack/react-query&#x27;</span><span class="token" style="color:#d4d4d4">;</span><span>
</span>
<span></span><span class="token" style="color:#6a9955">// 임의의 데이터 fetch 함수</span><span>
</span><span></span><span class="token" style="color:#569CD6">async</span><span> </span><span class="token" style="color:#569CD6">function</span><span> </span><span class="token" style="color:#dcdcaa">fetchData</span><span class="token" style="color:#d4d4d4">(</span><span class="token" style="color:#d4d4d4">)</span><span> </span><span class="token" style="color:#d4d4d4">{</span><span>
</span><span>  </span><span class="token" style="color:#6a9955">// 실제 네트워크 딜레이를 시뮬레이션</span><span>
</span><span>  </span><span class="token" style="color:#c586c0">await</span><span> </span><span class="token" style="color:#569CD6">new</span><span> </span><span class="token known-class-name" style="color:#4ec9b0">Promise</span><span class="token" style="color:#d4d4d4">(</span><span>resolve </span><span class="token" style="color:#569CD6">=&gt;</span><span> </span><span class="token" style="color:#dcdcaa">setTimeout</span><span class="token" style="color:#d4d4d4">(</span><span>resolve</span><span class="token" style="color:#d4d4d4">,</span><span> </span><span class="token" style="color:#b5cea8">1000</span><span class="token" style="color:#d4d4d4">)</span><span class="token" style="color:#d4d4d4">)</span><span class="token" style="color:#d4d4d4">;</span><span>
</span><span>  </span><span class="token" style="color:#6a9955">// ... API 호출 로직 ...</span><span>
</span><span>  </span><span class="token" style="color:#c586c0">return</span><span> </span><span class="token" style="color:#d4d4d4">{</span><span> title</span><span class="token" style="color:#d4d4d4">:</span><span> </span><span class="token" style="color:#ce9178">&#x27;Fetched Data on Client!&#x27;</span><span> </span><span class="token" style="color:#d4d4d4">}</span><span class="token" style="color:#d4d4d4">;</span><span>
</span><span></span><span class="token" style="color:#d4d4d4">}</span><span>
</span>
<span></span><span class="token" style="color:#c586c0">export</span><span> </span><span class="token" style="color:#c586c0">default</span><span> </span><span class="token" style="color:#569CD6">function</span><span> </span><span class="token" style="color:#dcdcaa">ClientComponent</span><span class="token" style="color:#d4d4d4">(</span><span class="token" style="color:#d4d4d4">)</span><span> </span><span class="token" style="color:#d4d4d4">{</span><span>
</span><span>  </span><span class="token" style="color:#6a9955">// 이 코드는 이제 ssr: false 덕분에 클라이언트에서만 실행되므로 안전합니다.</span><span>
</span><span>  </span><span class="token" style="color:#569CD6">const</span><span> </span><span class="token" style="color:#d4d4d4">{</span><span> data </span><span class="token" style="color:#d4d4d4">}</span><span> </span><span class="token" style="color:#d4d4d4">=</span><span> </span><span class="token" style="color:#dcdcaa">useSuspenseQuery</span><span class="token" style="color:#d4d4d4">(</span><span class="token" style="color:#d4d4d4">{</span><span>
</span><span>    queryKey</span><span class="token" style="color:#d4d4d4">:</span><span> </span><span class="token" style="color:#d4d4d4">[</span><span class="token" style="color:#ce9178">&#x27;data&#x27;</span><span class="token" style="color:#d4d4d4">]</span><span class="token" style="color:#d4d4d4">,</span><span>
</span><span>    queryFn</span><span class="token" style="color:#d4d4d4">:</span><span> fetchData
</span><span>  </span><span class="token" style="color:#d4d4d4">}</span><span class="token" style="color:#d4d4d4">)</span><span class="token" style="color:#d4d4d4">;</span><span>
</span>
<span>  </span><span class="token" style="color:#c586c0">return</span><span> </span><span class="token" style="color:#d4d4d4">&lt;</span><span>div</span><span class="token" style="color:#d4d4d4">&gt;</span><span class="token" style="color:#d4d4d4">{</span><span>data</span><span class="token" style="color:#d4d4d4">.</span><span class="token property-access">title</span><span class="token" style="color:#d4d4d4">}</span><span class="token" style="color:#d4d4d4">&lt;</span><span class="token" style="color:#d4d4d4">/</span><span>div</span><span class="token" style="color:#d4d4d4">&gt;</span><span class="token" style="color:#d4d4d4">;</span><span>
</span><span></span><span class="token" style="color:#d4d4d4">}</span></code></div></pre>
<p>코드 예시를 통해 해결 방법이 얼마나 간단하고 명확한지 확인하셨을 것입니다. 이제 마지막으로 이 경험을 통해 얻을 수 있는 중요한 교훈을 정리해 보겠습니다.</p>
<ol start="6">
<li>결론: App Router 렌더링 전략의 이해</li>
</ol>
<p>useSuspenseQuery와 클라이언트 컴포넌트 조합 사용 시 발생한 서버 행 이슈는 단순한 버그가 아닙니다. 이는 Next.js App Router가 채택한 렌더링 모델에 대한 깊은 이해가 왜 중요한지를 보여주는 매우 좋은 사례이며, 의도적인 렌더링 경계 설계의 필요성을 역설합니다.</p>
<p>이 글을 통해 우리가 얻은 핵심 교훈은 다음과 같습니다.</p>
<ul>
<li>핵심 교훈 1: &#x27;use client&#x27;는 서버 렌더링을 배제하는 지시어가 아닙니다. 이는 서버에서 사전 렌더링 후 클라이언트에서 하이드레이션하는, 즉 SSR과 CSR이 결합된 App Router의 기본 모델을 의미합니다.</li>
<li>핵심 교훈 2: 만약 컴포넌트가 서버 환경에서는 실행되어서는 안 되는 클라이언트 전용 데이터 페칭 로직이나 API를 포함하고 있다면, next/dynamic과 ssr: false 옵션을 사용하는 것은 단순한 문제 해결이 아닌, 필수적인 아키텍처 결정입니다. 이를 통해 명확한 CSR 경계를 설정해야 합니다.</li>
</ul>
<p>이제 여러분은 Next.js의 렌더링 전략을 더 효과적으로 활용할 준비가 되었습니다. 이 글에서 다룬 원리와 해결책을 바탕으로 유사한 문제를 예방하고, 더욱 견고하고 안정적인 애플리케이션을 구축하시기를 바랍니다.</p></div></div><!--$--><!--/$--><script src="/_next/static/chunks/a493a3c4f2b38b68.js" id="_R_" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"1:\"$Sreact.fragment\"\n2:I[27531,[\"/_next/static/chunks/28ff6a04602448ba.js\",\"/_next/static/chunks/64c697a3cb51cd07.js\"],\"default\"]\n3:I[44600,[\"/_next/static/chunks/28ff6a04602448ba.js\",\"/_next/static/chunks/64c697a3cb51cd07.js\"],\"default\"]\n5:I[97990,[\"/_next/static/chunks/28ff6a04602448ba.js\",\"/_next/static/chunks/64c697a3cb51cd07.js\"],\"OutletBoundary\"]\n6:\"$Sreact.suspense\"\n8:I[97990,[\"/_next/static/chunks/28ff6a04602448ba.js\",\"/_next/static/chunks/64c697a3cb51cd07.js\"],\"ViewportBoundary\"]\na:I[97990,[\"/_next/static/chunks/28ff6a04602448ba.js\",\"/_next/static/chunks/64c697a3cb51cd07.js\"],\"MetadataBoundary\"]\nc:I[60740,[\"/_next/static/chunks/28ff6a04602448ba.js\",\"/_next/static/chunks/64c697a3cb51cd07.js\"],\"default\"]\n:HL[\"/_next/static/chunks/78e1cd5791fa066e.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"0:{\"P\":null,\"b\":\"xcUo785Y1ppM0QMMmzB_a\",\"c\":[\"\",\"blog\",\"app-router-useSuspenseQuery\"],\"q\":\"\",\"i\":false,\"f\":[[[\"\",{\"children\":[\"blog\",{\"children\":[[\"id\",\"app-router-useSuspenseQuery\",\"d\"],{\"children\":[\"__PAGE__\",{}]}]}]},\"$undefined\",\"$undefined\",true],[[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/chunks/78e1cd5791fa066e.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[\"$\",\"html\",null,{\"lang\":\"en\",\"children\":[[\"$\",\"link\",null,{\"rel\":\"icon\",\"type\":\"image/svg+xml\",\"href\":\"/vite.svg\"}],[\"$\",\"body\",null,{\"className\":\"bg-white dark:bg-gray-900 text-gray-900 dark:text-gray-100\",\"children\":[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":404}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],[]],\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]}]]}]]}],{\"children\":[[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[[\"$\",\"$1\",\"c\",{\"children\":[\"$L4\",[[\"$\",\"script\",\"script-0\",{\"src\":\"/_next/static/chunks/0d67ebe65980c00f.js\",\"async\":true,\"nonce\":\"$undefined\"}],[\"$\",\"script\",\"script-1\",{\"src\":\"/_next/static/chunks/8307872c0df20eb5.js\",\"async\":true,\"nonce\":\"$undefined\"}]],[\"$\",\"$L5\",null,{\"children\":[\"$\",\"$6\",null,{\"name\":\"Next.MetadataOutlet\",\"children\":\"$@7\"}]}]]}],{},null,false,false]},null,false,false]},null,false,false]},null,false,false],[\"$\",\"$1\",\"h\",{\"children\":[null,[\"$\",\"$L8\",null,{\"children\":\"$L9\"}],[\"$\",\"div\",null,{\"hidden\":true,\"children\":[\"$\",\"$La\",null,{\"children\":[\"$\",\"$6\",null,{\"name\":\"Next.Metadata\",\"children\":\"$Lb\"}]}]}],null]}],false]],\"m\":\"$undefined\",\"G\":[\"$c\",[]],\"S\":true}\n"])</script><script>self.__next_f.push([1,"d:I[70451,[\"/_next/static/chunks/0d67ebe65980c00f.js\",\"/_next/static/chunks/8307872c0df20eb5.js\"],\"\"]\ne:I[74553,[\"/_next/static/chunks/0d67ebe65980c00f.js\",\"/_next/static/chunks/8307872c0df20eb5.js\"],\"PostViewer\"]\nf:T29be,"])</script><script>self.__next_f.push([1,"\n1. 서론: 끝나지 않는 로딩의 미스터리\n\nNext.js App Router는 서버 컴포넌트와 클라이언트 컴포넌트의 유연한 조합을 통해 강력한 웹 애플리케이션 구축을 가능하게 합니다. 하지만 이 새로운 렌더링 패러다임은 강력한 만큼, 기존의 클라이언트 중심 멘탈 모델과 충돌하며 흔한 함정을 만들어냅니다. 그 대표적인 사례가 바로 @tanstack/react-query의 useSuspenseQuery를 클라이언트 컴포넌트에서 사용했을 때 발생하는 '서버 행(Hanging)' 현상, 즉 페이지 응답이 멈추고 무한 로딩에 빠지는 문제입니다.\n\n이 글은 이 문제를 단순한 버그가 아닌, 서버 우선 렌더링 모델과 클라이언트 데이터 페칭 패턴이 충돌할 때 발생하는 예측 가능한 결과로 분석합니다. 우리는 이 현상의 근본 원인을 명확히 파헤치고, next/dynamic을 활용해 의도적인 렌더링 경계를 설정하는 확실한 해결책을 제시할 것입니다. 이제 문제 상황을 구체적으로 재현하며 본격적인 분석을 시작하겠습니다.\n\n2. 문제 현상 분석: useSuspenseQuery가 서버를 멈추게 할 때\n\n모든 문제 해결의 첫걸음은 현상을 명확하게 정의하고 재현하는 것입니다. 정확한 진단 없이는 올바른 처방을 내릴 수 없기 때문입니다. 어떤 환경과 코드 구조에서 이 문제가 발생하는지 구체적으로 살펴보겠습니다.\n\n문제는 다음과 같은 시나리오에서 발생합니다.\n\n* 환경: Next.js App Router\n* 구조: 서버 컴포넌트(Server Component)가 `\u003cSuspense\u003e` fallback UI로 클라이언트 컴포넌트(Client Component)를 감싸는 구조\n* 핵심 원인: 감싸진 클라이언트 컴포넌트 내부에서 @tanstack/react-query의 useSuspenseQuery를 호출함\n\n이 조건들이 충족될 때 나타나는 가장 명백한 증상은 다음과 같습니다. 페이지 응답이 완료되지 않고 브라우저 탭의 파비콘이 계속 로딩 상태로 남아있는 '서버 행(Hanging)' 현상이 발생합니다. 사용자는 아무런 콘텐츠도 보지 못한 채 끝없이 기다리게 되고, 개발자 도구의 네트워크 탭을 봐도 응답이 오지 않는 것을 확인할 수 있습니다.\n\n이처럼 서버가 응답을 멈추는 현상은 왜 발생하는 것일까요? 이 근본적인 원인을 파헤치기 위해서는, 우리가 흔히 오해하는 클라이언트 컴포넌트의 렌더링 방식에 대한 정확한 이해가 필요합니다.\n\n3. 근본 원인 탐구: 'use client'의 오해와 진실\n\n단순히 현상을 해결하는 것을 넘어, Next.js App Router의 핵심 렌더링 메커니즘을 이해하는 것은 매우 중요합니다. 이번 문제의 근원은 바로 'use client' 지시어에 대한 흔한 오해에서 비롯됩니다.\n\n'use client'는 CSR을 의미하지 않는다\n\n많은 개발자가 'use client' 지시어를 파일 상단에 추가하면 해당 컴포넌트가 오직 브라우저에서만 렌더링(Client-Side Rendering, CSR)될 것이라고 생각합니다. 하지만 이는 사실이 아닙니다. 이 동작은 Next.js에 국한된 것이 아니라, React 18의 Suspense 기반 SSR의 고유한 특성입니다. 'use client'의 정확한 의미는 다음과 같습니다.\n\n* Pre-rendering (사전 렌더링): 'use client'로 명시된 컴포넌트조차도, 최초 페이지 로드 시에는 서버에서 초기 HTML 뼈대를 미리 렌더링(Server-Side Rendering, SSR)합니다.\n* Hydration (하이드레이션): 이후 브라우저에서 JavaScript 번들이 로드되면, 서버가 생성한 HTML 위에 이벤트 핸들러 등을 연결하여 상호작용이 가능한 완전한 컴포넌트로 '깨우는' 과정을 거칠니다.\n\n즉, 별도의 설정이 없는 한 모든 클라이언트 컴포넌트는 서버에서 최소 한 번 실행됩니다. 바로 이 지점이 useSuspenseQuery가 서버 행을 유발하는 원인입니다. 그 메커니즘은 다음과 같습니다.\n\n1. 서버 렌더링 시도: 사용자가 페이지에 접속하면, Next.js 서버는 UI를 구성하는 클라이언트 컴포넌트의 최초 HTML 렌더링을 시도합니다.\n2. 데이터 부재와 Suspend: 서버 환경에는 react-query가 관리하는 클라이언트 측 캐시 데이터가 존재하지 않습니다. 따라서 useSuspenseQuery는 데이터를 가져오기 위해 Promise를 던지고(throw), 컴포넌트를 'Suspend(일시 중단)' 상태로 만듭니다.\n3. 무한 대기: 서버에 있는 부모 `\u003cSuspense\u003e` 경계가 이 Promise를 감지합니다. 이는 Next.js 서버의 렌더러에게 \"이 부분의 HTML 생성을 중단하고 Promise가 해결될 때까지 기다려라\"는 신호입니다. 하지만 이 Promise는 클라이언트 사이드 데이터 페칭 로직이므로 서버에서는 절대 해결될 수 없습니다. 결과적으로, Next.js 서버의 응답 스트림 전송이 중단된 채 무기한 대기하게 되는 '행(Hanging)' 상태에 빠집니다.\n\n결국 문제의 원인은 클라이언트에서만 실행되어야 할 데이터 페칭 로직이 서버 렌더링 과정 중 시도되었기 때문입니다. 이를 해결하기 위한 전략은 명확합니다. 해당 컴포넌트의 서버 렌더링 자체를 의도적으로 비활성화하는 것입니다.\n\n4. 해결책 제시: next/dynamic과 ssr: false 옵션\n\n문제의 원인이 서버 렌더링 시도에 있다는 것을 파악했으니, 이제 명확한 해결책을 제시할 차례입니다. 우리는 해당 컴포넌트를 기본 SSR/Hydration 모델에서 의도적으로 제외하고, 순수한 클라이언트 사이드 렌더링(CSR) 경계를 설정해야 합니다.\n\n이때 사용할 수 있는 가장 강력한 도구가 바로 Next.js의 내장 기능인 next/dynamic입니다. next/dynamic은 컴포넌트를 동적으로 임포트하게 해주며, 특히 ssr: false 옵션과 함께 사용될 때 이 문제의 완벽한 해결책이 됩니다.\n\nssr: false 옵션의 역할은 매우 직관적입니다. 이것은 Next.js 서버에게 **\"이 컴포넌트의 HTML은 미리 만들지 말고, 브라우저에서 JavaScript가 로드된 후에 렌더링을 시작하라\"**고 명확히 지시하는 것과 같습니다.\n\n이 해결책을 적용했을 때 얻게 되는 결과는 다음과 같습니다.\n\n* 서버는 해당 컴포넌트의 렌더링을 완전히 건너뛰고 나머지 페이지의 HTML을 구성하여 즉시 클라이언트에 응답을 보냅니다.\n* 클라이언트(브라우저)는 초기 HTML을 받은 후, 해당 컴포넌트의 JavaScript 코드를 비동기적으로 로드합니다.\n* 로드가 완료되면, 실제 데이터 페칭(useSuspenseQuery)과 렌더링은 온전히 클라이언트 환경에서만 일어나므로 서버 행 이슈가 근본적으로 해결됩니다.\n\n이론적 설명을 마쳤으니, 이제 실제 코드를 통해 이 해결책을 어떻게 적용하는지 구체적으로 살펴보겠습니다.\n\n5. 적용 코드 예시: 문제 해결의 실제\n\n앞서 설명한 해결책을 실제 코드에 어떻게 적용하는지 보여드리겠습니다. 부모인 서버 컴포넌트에서 useSuspenseQuery를 사용하는 자식 클라이언트 컴포넌트를 불러오는 방식을 어떻게 변경하는지 집중해서 보시기 바랍니다.\n\n먼저 부모 컴포넌트인 **ServerComponent.tsx**의 변경 사항입니다. import 구문을 next/dynamic으로 대체하고 ssr: false 옵션을 추가합니다.\n\n```typescript\n// ServerComponent.tsx (부모 컴포넌트)\nimport dynamic from 'next/dynamic';\n\n// 핵심: ssr: false 옵션으로 서버 렌더링을 비활성화\nconst ClientComponentWithNoSSR = dynamic(\n  () =\u003e import('./ClientComponent'),\n  {\n    ssr: false,\n    // 컴포넌트의 JS가 로드되는 동안 보여줄 UI\n    loading: () =\u003e \u003cp\u003eLoading...\u003c/p\u003e,\n  }\n);\n\nexport default function Page() {\n  return (\n    \u003cdiv\u003e\n      \u003ch1\u003eMy Page\u003c/h1\u003e\n      {/* 서버 행 이슈 없이 클라이언트에서만 렌더링됩니다. */}\n      \u003cClientComponentWithNoSSR /\u003e\n    \u003c/div\u003e\n  );\n}\n```\n\n\n다음은 **ClientComponent.tsx**의 코드입니다. 흥미롭게도 이 컴포넌트의 코드는 전혀 변경할 필요가 없습니다. next/dynamic을 통해 렌더링 제어의 책임이 부모 컴포넌트로 넘어갔기 때문입니다.\n\n```typescript\n// ClientComponent.tsx (자식 컴포넌트)\n'use client';\n\nimport { useSuspenseQuery } from '@tanstack/react-query';\n\n// 임의의 데이터 fetch 함수\nasync function fetchData() {\n  // 실제 네트워크 딜레이를 시뮬레이션\n  await new Promise(resolve =\u003e setTimeout(resolve, 1000));\n  // ... API 호출 로직 ...\n  return { title: 'Fetched Data on Client!' };\n}\n\nexport default function ClientComponent() {\n  // 이 코드는 이제 ssr: false 덕분에 클라이언트에서만 실행되므로 안전합니다.\n  const { data } = useSuspenseQuery({\n    queryKey: ['data'],\n    queryFn: fetchData\n  });\n\n  return \u003cdiv\u003e{data.title}\u003c/div\u003e;\n}\n```\n\n\n코드 예시를 통해 해결 방법이 얼마나 간단하고 명확한지 확인하셨을 것입니다. 이제 마지막으로 이 경험을 통해 얻을 수 있는 중요한 교훈을 정리해 보겠습니다.\n\n6. 결론: App Router 렌더링 전략의 이해\n\nuseSuspenseQuery와 클라이언트 컴포넌트 조합 사용 시 발생한 서버 행 이슈는 단순한 버그가 아닙니다. 이는 Next.js App Router가 채택한 렌더링 모델에 대한 깊은 이해가 왜 중요한지를 보여주는 매우 좋은 사례이며, 의도적인 렌더링 경계 설계의 필요성을 역설합니다.\n\n이 글을 통해 우리가 얻은 핵심 교훈은 다음과 같습니다.\n\n* 핵심 교훈 1: 'use client'는 서버 렌더링을 배제하는 지시어가 아닙니다. 이는 서버에서 사전 렌더링 후 클라이언트에서 하이드레이션하는, 즉 SSR과 CSR이 결합된 App Router의 기본 모델을 의미합니다.\n* 핵심 교훈 2: 만약 컴포넌트가 서버 환경에서는 실행되어서는 안 되는 클라이언트 전용 데이터 페칭 로직이나 API를 포함하고 있다면, next/dynamic과 ssr: false 옵션을 사용하는 것은 단순한 문제 해결이 아닌, 필수적인 아키텍처 결정입니다. 이를 통해 명확한 CSR 경계를 설정해야 합니다.\n\n이제 여러분은 Next.js의 렌더링 전략을 더 효과적으로 활용할 준비가 되었습니다. 이 글에서 다룬 원리와 해결책을 바탕으로 유사한 문제를 예방하고, 더욱 견고하고 안정적인 애플리케이션을 구축하시기를 바랍니다."])</script><script>self.__next_f.push([1,"4:[\"$\",\"div\",null,{\"className\":\"p-8 max-w-4xl mx-auto\",\"children\":[[\"$\",\"$Ld\",null,{\"href\":\"/\",\"className\":\"text-blue-500 hover:underline mb-4 inline-block\",\"children\":\"← Back to List\"}],[\"$\",\"header\",null,{\"className\":\"mb-8\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"text-4xl font-bold mb-4 text-gray-900 dark:text-gray-100\",\"children\":\"Next.js App Router: useSuspenseQuery 서버 행(Hanging) 이슈 해결\"}],[\"$\",\"div\",null,{\"className\":\"text-gray-500 dark:text-gray-400\",\"children\":[\"2025-12-20\",[\"$\",\"span\",null,{\"className\":\"ml-2\",\"children\":[\"• \",\"#Next.js #React Query #App Router\"]}]]}]]}],[\"$\",\"$Le\",null,{\"content\":\"$f\"}]]}]\n"])</script><script>self.__next_f.push([1,"9:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"meta\",\"1\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}]]\n"])</script><script>self.__next_f.push([1,"7:null\nb:[[\"$\",\"title\",\"0\",{\"children\":\"Dev-Holic Blog\"}],[\"$\",\"meta\",\"1\",{\"name\":\"description\",\"content\":\"Dev-Holic Blog\"}]]\n"])</script></body></html>